tags: read
title: 《Java 8编程参考官方教程(第9版)》- 目录

## 第Ⅰ部分 Java 语 言 
	

#### 第1章 Java的历史和演变	3 

	1.1 Java的家世	4 
	1.1.1 现代编程语言的诞生：C语言	4 
	1.1.2 C++：下一个阶段	5 
	1.1.3 Java出现的时机已经成熟	6 
	1.2 Java的诞生	6 
	1.3 Java改变Internet的方式	8 
	1.3.1 Java applet	8 
	1.3.2 安全性	8 
	1.3.3 可移植性	8 
	1.4 Java的魔力：字节码	9 
	1.5 servlet：服务器端的Java	10 
	1.6 Java的关键特性	10 
	1.6.1 简单性	10 
	1.6.2 面向对象	11 
	1.6.3 健壮性	11 
	1.6.4 多线程	11 
	1.6.5 体系结构中立	11 
	1.6.6 解释执行和高性能	12 
	1.6.7 分布式	12 
	1.6.8 动态性	12 
	1.7 Java的演变历程	12 
	1.8 Java SE 8	14 
	1.9 文化革新	15 

#### 第2章 Java综述	17 

	2.1 面向对象编程	17 
	2.1.1 两种范式	18 
	2.1.2 抽象	18 
	2.1.3 OOP三原则	19 
	2.2 第一个简单程序	23 
	2.2.1 输入程序	23 
	2.2.2 编译程序	23 
	2.2.3 深入分析第一个示例程序	24 
	2.3 第二个简短程序	26 
	2.4 两种控制语句	27 
	2.4.1 if语句	27 
	2.4.2 for循环	29 
	2.5 使用代码块	30 
	2.6 词汇问题	31 
	2.6.1 空白符	32 
	2.6.2 标识符	32 
	2.6.3 字面值	32 
	2.6.4 注释	32 
	2.6.5 分隔符	32 
	2.6.6 Java关键字	33 
	2.7 Java类库	34 

#### 第3章 数据类型、变量和数组	35 

	3.1 Java是强类型化的语言	35 
	3.2 基本类型	36 
	3.3 整型	36 
	3.3.1 byte	37 
	3.3.2 short	37 
	3.3.3 int	37 
	3.3.4 long	37 
	3.4 浮点型	38 
	3.4.1 float	38 
	3.4.2 double	39 
	3.5 字符型	39 
	3.6 布尔型	41 
	3.7 深入分析字面值	42 
	3.7.1 整型字面值	42 
	3.7.2 浮点型字面值	43 
	3.7.3 布尔型字面值	43 
	3.7.4 字符型字面值	43 
	3.7.5 字符串字面值	44 
	3.8 变量	45 
	3.8.1 变量的声明	45 
	3.8.2 动态初始化	45 
	3.8.3 变量的作用域和生存期	46 
	3.9 类型转换和强制类型转换	48 
	3.9.1 Java的自动类型转换	48 
	3.9.2 强制转换不兼容的类型	48 
	3.10 表达式中的自动类型提升	50 
	3.11 数组	51 
	3.11.1 一维数组	51 
	3.11.2 多维数组	54 
	3.11.3 另一种数组声明语法	58 
	3.12 关于字符串的一些说明	58 
	3.13 向C/C++程序员提供指针方面的说明	59 

#### 第4章 运算符	61 

	4.1 算术运算符	61 
	4.1.1 基本算术运算符	62 
	4.1.2 求模运算符	63 
	4.1.3 算术与赋值复合运算符	64 
	4.1.4 自增与自减运算符	65 
	4.2 位运算符	66 
	4.2.1 位逻辑运算符	67 
	4.2.2 左移	70 
	4.2.3 右移	71 
	4.2.4 无符号右移	72 
	4.2.5 位运算符与赋值的组合	74 
	4.3 关系运算符	74 
	4.4 布尔逻辑运算符	75 
	4.5 赋值运算符	77 
	4.6 “?”运算符	78 
	4.7 运算符的优先级	79 
	4.8 使用圆括号	80 

#### 第5章 控制语句	81 

	5.1 Java的选择语句	81 
	5.1.1 if语句	82 
	5.1.2 switch语句	84 
	5.2 迭代语句	89 
	5.2.1 while语句	89 
	5.2.2 do-while语句	91 
	5.2.3 for语句	93 
	5.2.4 for循环的for-each版本	97 
	5.2.5 嵌套的循环	102 
	5.3 跳转语句	103 
	5.3.1 使用break语句	103 
	5.3.2 使用continue语句	107 
	5.3.3 return语句	108 

#### 第6章 类	111 

	6.1 类的基础知识	112 
	6.1.1 类的一般形式	112 
	6.1.2 一个简单的类	113 
	6.2 声明对象	115 
	6.3 为对象引用变量赋值	117 
	6.4 方法	118 
	6.4.1 为Box类添加方法	118 
	6.4.2 返回值	120 
	6.4.3 添加带参数的方法	121 
	6.5 构造函数	123 
	6.6 this关键字	126 
	6.7 垃圾回收	127 
	6.8 finalize()方法	128 
	6.9 堆栈类	128 

#### 第7章 方法和类的深入分析	131 

	7.1 重载方法	131 
	7.2 将对象用作参数	136 
	7.3 参数传递的深入分析	139 
	7.4 返回对象	141 
	7.5 递归	142 
	7.6 访问控制	144 
	7.7 理解static	147 
	7.8 final介绍	149 
	7.9 重新审视数组	149 
	7.10 嵌套类和内部类	151 
	7.11 String类介绍	154 
	7.12 使用命令行参数	156 
	7.13 varargs：可变长度参数	157 
	7.13.1 重载varargs方法	160 
	7.13.2 varargs方法与模糊性	161 

#### 第8章 继承	165 

	8.1 继承的基础知识	165 
	8.1.1 成员访问与继承	167 
	8.1.2 一个更实际的例子	168 
	8.1.3 超类变量可以引用子类对象	170 
	8.2 使用super关键字	171 
	8.2.1 使用super调用超类的构造函数	171 
	8.2.2 super的另一种用法	175 
	8.3 创建多级继承层次	176 
	8.4 构造函数的调用时机	179 
	8.5 方法重写	180 
	8.6 动态方法调度	183 
	8.6.1 重写方法的目的	184 
	8.6.2 应用方法重写	185 
	8.7 使用抽象类	186 
	8.8 在继承中使用final关键字	189 
	8.8.1 使用final关键字阻止重写	189 
	8.8.2 使用final关键字阻止继承	190 
	8.9 Object类	190 

#### 第9章 包和接口	193 

	9.1 包	194 
	9.1.1 定义包	194 
	9.1.2 包查找与CLASSPATH	195 
	9.1.3 一个简短的包示例	195 
	9.2 访问保护	196 
	9.3 导入包	200 
	9.4 接口	202 
	9.4.1 定义接口	202 
	9.4.2 实现接口	203 
	9.4.3 嵌套接口	206 
	9.4.4 应用接口	207 
	9.4.5 接口中的变量	210 
	9.4.6 接口可以扩展	212 
	9.5 默认接口方法	213 
	9.5.1 默认方法的基础知识	214 
	9.5.2 一个更加实用的例子	215 
	9.5.3 多级继承的问题	216 
	9.6 在接口中使用静态方法	217 
	9.7 关于包和接口的最后说明	218 

#### 第10章 异常处理	219 

	10.1 异常处理的基础知识	219 
	10.2 异常类型	220 
	10.3 未捕获的异常	221 
	10.4 使用try和catch	222 
	10.5 多条catch子句	224 
	10.6 嵌套的try语句	225 
	10.7 throw	228 
	10.8 throws	229 
	10.9 finally	230 
	10.10 Java的内置异常	232 
	10.11 创建自己的异常子类	233 
	10.12 链式异常	235 
	10.13 3个近期添加的异常特性	237 
	10.14 使用异常	238 

#### 第11章 多线程编程	239 

	11.1 Java线程模型	240 
	11.1.1 线程优先级	241 
	11.1.2 同步	241 
	11.1.3 消息传递	242 
	11.1.4 Thread类和Runnable接口	242 
	11.2 主线程	243 
	11.3 创建线程	244 
	11.3.1 实现Runnable接口	245 
	11.3.2 扩展Thread类	247 
	11.3.3 选择一种创建方式	248 
	11.4 创建多个线程	248 
	11.5 使用isAlive()和join()方法	249 
	11.6 线程优先级	252 
	11.7 同步	253 
	11.7.1 使用同步方法	253 
	11.7.2 synchronized语句	255 
	11.8 线程间通信	257 
	11.9 挂起、恢复与停止线程	263 
	11.10 获取线程的状态	266 
	11.11 使用多线程	267 

#### 第12章 枚举、自动装箱与注解(元数据)	269 

	12.1 枚举	269 
	12.1.1 枚举的基础知识	270 
	12.1.2 values()和valueOf()方法	272 
	12.1.3 Java枚举是类类型	273 
	12.1.4 枚举继承自Enum类	275 
	12.1.5 另一个枚举示例	277 
	12.2 类型封装器	279 
	12.2.1 Character封装器	279 
	12.2.2 Boolean封装器	279 
	12.2.3 数值类型封装器	280 
	12.3 自动装箱	281 
	12.3.1 自动装箱与方法	281 
	12.3.2 表达式中发生的自动装箱/拆箱	282 
	12.3.3 布尔型和字符型数值的自动装箱/拆箱	284 
	12.3.4 自动装箱/拆箱有助于防止错误	285 
	12.3.5 一些警告	285 
	12.4 注解(元数据)	286 
	12.4.1 注解的基础知识	286 
	12.4.2 指定保留策略	287 
	12.4.3 在运行时使用反射获取注解	288 
	12.4.4 AnnotatedElement接口	293 
	12.4.5 使用默认值	293 
	12.4.6 标记注解	295 
	12.4.7 单成员注解	296 
	12.4.8 内置注解	297 
	12.5 类型注解	299 
	12.6 重复注解	303 

#### 第13章 I/O、applet以及其他主题	307 

	13.1 I/O的基础知识	308 
	13.1.1 流	308 
	13.1.2 字节流和字符流	308 
	13.1.3 预定义流	310 
	13.2 读取控制台输入	311 
	13.2.1 读取字符	311 
	13.2.2 读取字符串	312 
	13.3 向控制台写输出	314 
	13.4 PrintWriter类	314 
	13.5 读/写文件	315 
	13.6 自动关闭文件	321 
	13.7 applet的基础知识	325 
	13.8 transient和volatile修饰符	327 
	13.9 使用instanceof运算符	328 
	13.10 strictfp	330 
	13.11 本地方法	331 
	13.12 使用assert	334 
	13.13 静态导入	337 
	13.14 通过this()调用重载的构造函数	339 
	13.15 紧凑API配置文件	342 

#### 第14章 泛型	343 

	14.1 什么是泛型	344 
	14.2 一个简单的泛型示例	344 
	14.2.1 泛型只使用引用类型	348 
	14.2.2 基于不同类型参数的泛型类型是不同的	348 
	14.2.3 泛型提升类型安全性的原理	348 
	14.3 带两个类型参数的泛型类	350 
	14.4 泛型类的一般形式	352 
	14.5 有界类型	352 
	14.6 使用通配符参数	355 
	14.7 创建泛型方法	363 
	14.8 泛型接口	366 
	14.9 原始类型与遗留代码	368 
	14.10 泛型类层次	370 
	14.10.1 使用泛型超类	370 
	14.10.2 泛型子类	372 
	14.10.3 泛型层次中的运行时类型比较	374 
	14.10.4 强制转换	376 
	14.10.5 重写泛型类的方法	376 
	14.11 泛型的类型推断	378 
	14.12 擦除	379 
	14.13 模糊性错误	381 
	14.14 使用泛型的一些限制	382 
	14.14.1 不能实例化类型参数	382 
	14.14.2 对静态成员的一些限制	383 
	14.14.3 对泛型数组的一些限制	383 
	14.14.4 对泛型异常的限制	384 

#### 第15章 lambda表达式	385 

	15.1 lambda表达式简介	386 
	15.1.1 lambda表达式的基础知识	386 
	15.1.2 函数式接口	387 
	15.1.3 几个lambda表达式示例	388 
	15.2 块lambda表达式	391 
	15.3 泛型函数式接口	393 
	15.4 作为参数传递lambda表达式	395 
	15.5 lambda表达式与异常	398 
	15.6 lambda表达式和变量捕获	399 
	15.7 方法引用	400 
	15.7.1 静态方法的方法引用	400 
	15.7.2 实例方法的方法引用	401 
	15.7.3 泛型中的方法引用	405 
	15.8 构造函数引用	408 
	15.9 预定义的函数式接口	412 
	
## 第Ⅱ部分 Java库 
	

#### 第16章 字符串处理	417 

	16.1 String类的构造函数	418 
	16.2 字符串的长度	420 
	16.3 特殊的字符串操作	420 
	16.3.1 字符串字面值	421 
	16.3.2 字符串连接	421 
	16.3.3 字符串和其他数据类型的连接	421 
	16.3.4 字符串转换和toString()方法	422 
	16.4 提取字符	423 
	16.4.1 charAt()	424 
	16.4.2 getChars()	424 
	16.4.3 getBytes()	424 
	16.4.4 toCharArray()	425 
	16.5 比较字符串	425 
	16.5.1 equals()和equalsIgnoreCase()	425 
	16.5.2 regionMatches()	426 
	16.5.3 startsWith()和endsWith()	426 
	16.5.4 equals()与==	427 
	16.5.5 compareTo()	427 
	16.6 查找字符串	429 
	16.7 修改字符串	430 
	16.7.1 substring()	430 
	16.7.2 concat()	431 
	16.7.3 replace()	432 
	16.7.4 trim()	432 
	16.8 使用valueOf()转换数据	433 
	16.9 改变字符串中字符的大小写	434 
	16.10 连接字符串	434 
	16.11 其他String方法	435 
	16.12 StringBuffer类	436 
	16.12.1 StringBuffer类的构造函数	437 
	16.12.2 length()与capacity()	437 
	16.12.3 ensureCapacity()	438 
	16.12.4 setLength()	438 
	16.12.5 charAt()与setCharAt()	438 
	16.12.6 getChars()	439 
	16.12.7 append()	439 
	16.12.8 insert()	440 
	16.12.9 reverse()	440 
	16.12.10 delete()与deleteCharAt()	441 
	16.12.11 replace()	441 
	16.12.12 substring()	442 
	16.12.13 其他StringBuffer方法	442 
	16.13 StringBuilder类	443 

#### 第17章 探究java.lang	445 

	17.1 基本类型封装器	446 
	17.1.1 Number	446 
	17.1.2 Double与Float	447 
	17.1.3 理解isInfinite()与isNaN()	450 
	17.1.4 Byte、Short、Integer和Long	451 
	17.1.5 Character	459 
	17.1.6 对Unicode代码点的附加支持	462 
	17.1.7 Boolean	463 
	17.2 Void类	464 
	17.3 Process类	464 
	17.4 Runtime类	465 
	17.4.1 内存管理	466 
	17.4.2 执行其他程序	467 
	17.5 ProcessBuilder类	469 
	17.6 System类	471 
	17.6.1 使用currentTimeMillis()计时程序的执行	472 
	17.6.2 使用arraycopy()	473 
	17.6.3 环境属性	474 
	17.7 Object类	474 
	17.8 使用clone()方法和Cloneable接口	475 
	17.9 Class类	477 
	17.10 ClassLoader类	480 
	17.11 Math类	481 
	17.11.1 三角函数	481 
	17.11.2 指数函数	481 
	17.11.3 舍入函数	482 
	17.11.4 其他数学方法	483 
	17.12 StrictMath类	485 
	17.13 Compiler类	485 
	17.14 Thread类、ThreadGroup类和Runnable接口	485 
	17.14.1 Runnable接口	485 
	17.14.2 Thread类	486 
	17.14.3 ThreadGroup类	488 
	17.15 ThreadLocal和 
	InheritableThreadLocal类	492 
	17.16 Package类	492 
	17.17 RuntimePermission类	494 
	17.18 Throwable类	494 
	17.19 SecurityManager类	494 
	17.20 StackTraceElement类	494 
	17.21 Enum类	495 
	17.22 ClassValue类	496 
	17.23 CharSequence接口	496 
	17.24 Comparable接口	496 
	17.25 Appendable接口	497 
	17.26 Iterable接口	497 
	17.27 Readable接口	498 
	17.28 AutoCloseable接口	498 
	17.29 Thread.UncaughtExceptionHandler接口	498 
	17.30 java.lang子包	499 
	17.30.1 java.lang.annotation	499 
	17.30.2 java.lang.instrument	499 
	17.30.3 java.lang.invoke	499 
	17.30.4 java.lang.management	499 
	17.30.5 java.lang.ref	499 
	17.30.6 java.lang.reflect	499 

#### 第18章 java.util第1部分：集合框架	501 

	18.1 集合概述	503 
	18.2 JDK 5对集合框架的修改	504 
	18.2.1 泛型从根本上改变了集合框架	504 
	18.2.2 自动装箱使得使用基本类型更加容易	504 
	18.2.3 for-each风格的for循环	505 
	18.3 集合接口	505 
	18.3.1 Collection接口	506 
	18.3.2 List接口	508 
	18.3.3 Set接口	509 
	18.3.4 SortedSet接口	509 
	18.3.5 NavigableSet接口	510 
	18.3.6 Queue接口	511 
	18.3.7 Deque接口	512 
	18.4 集合类	514 
	18.4.1 ArrayList类	515 
	18.4.2 LinkedList类	518 
	18.4.3 HashSet类	520 
	18.4.4 LinkedHashSet类	521 
	18.4.5 TreeSet类	521 
	18.4.6 PriorityQueue类	523 
	18.4.7 ArrayDeque类	523 
	18.4.8 EnumSet类	524 
	18.5 通过迭代器访问集合	525 
	18.5.1 使用迭代器	527 
	18.5.2 使用for-each循环替代迭代器	528 
	18.6 Spliterator	529 
	18.7 在集合中存储用户定义的类	532 
	18.8 RandomAccess接口	533 
	18.9 使用映射	534 
	18.9.1 映射接口	534 
	18.9.2 映射类	539 
	18.10 比较器	544 
	18.11 集合算法	552 
	18.12 Arrays类	558 
	18.13 遗留的类和接口	563 
	18.13.1 Enumeration接口	564 
	18.13.2 Vector类	564 
	18.13.3 Stack类	568 
	18.13.4 Dictionary类	570 
	18.13.5 Hashtable类	571 
	18.13.6 Properties类	574 
	18.13.7 使用store()和load()	578 
	18.14 集合小结	580 

#### 第19章 java.util第2部分：更多实用工具类	581 

	19.1 StringTokenizer类	581 
	19.2 BitSet类	583 
	19.3 Optional、OptionalDouble、OptionalInt和OptionalLong	586 
	19.4 Date类	588 
	19.5 Calendar类	590 
	19.6 GregorianCalendar类	593 
	19.7 TimeZone类	595 
	19.8 SimpleTimeZone类	596 
	19.9 Locale类	597 
	19.10 Random类	598 
	19.11 Observable类	600 
	19.11.1 Observer接口	601 
	19.11.2 Observer示例	601 
	19.12 Timer和TimerTask类	604 
	19.13 Currency类	606 
	19.14 Formatter类	607 
	19.14.1 Formatter类的构造函数	607 
	19.14.2 Formatter类的方法	608 
	19.14.3 格式化的基础知识	609 
	19.14.4 格式化字符串和字符	611 
	19.14.5 格式化数字	611 
	19.14.6 格式化时间和日期	612 
	19.14.7 %n和%%说明符	614 
	19.14.8 指定最小字段宽度	614 
	19.14.9 指定精度	616 
	19.14.10 使用格式标志	617 
	19.14.11 对齐输出	617 
	19.14.12 空格、“+”、“0”以及“(”标志	618 
	19.14.13 逗号标志	619 
	19.14.14 “#”标志	619 
	19.14.15 大写选项	619 
	19.14.16 使用参数索引	620 
	19.14.17 关闭Formatter对象	621 
	19.14.18 printf()方法	622 
	19.15 Scanner类	622 
	19.15.1 Scanner类的构造函数	622 
	19.15.2 扫描的基础知识	623 
	19.15.3 一些Scanner示例	626 
	19.15.4 设置定界符	630 
	19.15.5 其他Scanner特性	632 
	19.16 ResourceBundle、ListResourceBundle和	633 
	19.17 其他实用工具类和接口	637 
	19.18 java.util子包	638 
	19.18.1 java.util.concurrent、java.util.concurrent.atomic和 java.util.concurrent.locks	638 
	19.18.2 java.util.function	638 
	19.18.3 java.util.jar	641 
	19.18.4 java.util.logging	641 
	19.18.5 java.util.prefs	641 
	19.18.6 java.util.regex	641 
	19.18.7 java.util.spi	642 
	19.18.8 java.util.stream	642 
	19.18.9 java.util.zip	642 

#### 第20章 输入/输出：探究java.io	643 

	20.1 I/O类和接口	644 
	20.2 File类	645 
	20.2.1 目录	648 
	20.2.2 使用FilenameFilter接口	649 
	20.2.3 listFiles()方法	650 
	20.2.4 创建目录	650 
	20.3 AutoCloseable、Closeable和Flushable接口	650 
	20.4 I/O异常	651 
	20.5 关闭流的两种方式	651 
	20.6 流类	653 
	20.7 字节流	653 
	20.7.1 InputStream类	653 
	20.7.2 OutputStream类	654 
	20.7.3 FileInputStream类	654 
	20.7.4 FileOutputStream类	656 
	20.7.5 ByteArrayInputStream类	659 
	20.7.6 ByteArrayOutputStream类	660 
	20.7.7 过滤的字节流	662 
	20.7.8 缓冲的字节流	662 
	20.7.9 SequenceInputStream类	666 
	20.7.10 PrintStream类	667 
	20.7.11 DataOutputStream和DataInputStream类	670 
	20.7.12 RandomAccessFile类	671 
	20.8 字符流	672 
	20.8.1 Reader类	672 
	20.8.2 Writer类	673 
	20.8.3 FileReader类	674 
	20.8.4 FileWriter类	675 
	20.8.5 CharArrayReader类	676 
	20.8.6 CharArrayWriter类	677 
	20.8.7 BufferedReader类	678 
	20.8.8 BufferedWriter类	680 
	20.8.9 PushbackReader类	680 
	20.8.10 PrintWriter类	681 
	20.9 Console类	682 
	20.10 串行化	684 
	20.10.1 Serializable接口	684 
	20.10.2 Externalizable接口	685 
	20.10.3 ObjectOutput接口	685 
	20.10.4 ObjectOutputStream类	685 
	20.10.5 ObjectInput接口	686 
	20.10.6 ObjectInputStream类	687 
	20.10.7 串行化示例	688 
	20.11 流的优点	690 

#### 第21章 探究NIO	691 

	21.1 NIO类	691 
	21.2 NIO的基础知识	692 
	21.2.1 缓冲区	692 
	21.2.2 通道	694 
	21.2.3 字符集和选择器	695 
	21.3 JDK 7对NIO的增强	696 
	21.3.1 Path接口	696 
	21.3.2 Files类	697 
	21.3.3 Path接口	700 
	21.3.4 文件属性接口	700 
	21.3.5 FileSystem、FileSystems和FileStore类	702 
	21.4 使用NIO系统	702 
	21.4.1 为基于通道的I/O使用NIO	703 
	21.4.2 为基于流的I/O使用NIO	712 
	21.4.3 为路径和文件系统操作使用NIO	714 
	21.5 JDK 7之前基于通道的例子	722 
	21.5.1 读文件(JDK 7之前)	722 
	21.5.2 写文件(JDK 7之前)	726 

#### 第22章 联网	729 

	22.1 联网的基础知识	730 
	22.2 联网类和接口	731 
	22.3 InetAddress类	732 
	22.3.1 工厂方法	732 
	22.3.2 实例方法	733 
	22.4 Inet4Address类和Inet6Address类	733 
	22.5 TCP/IP客户端套接字	734 
	22.6 URL类	737 
	22.7 URLConnection类	739 
	22.8 HttpURLConnection类	741 
	22.9 URI类	744 
	22.10 cookie	744 
	22.11 TCP/IP服务器套接字	744 
	22.12 数据报	745 
	22.12.1 DatagramSocket类	745 
	22.12.2 DatagramPacket类	746 
	22.12.3 数据报示例	747 

#### 第23章 Applet类	749 

	23.1 applet的两种类型	749 
	23.2 applet的基础知识	750 
	23.3 applet的架构	753 
	23.4 applet的骨架	753 
	23.4.1 applet的初始化和终止	755 
	23.4.2 重写update()方法	756 
	23.5 简单的applet显示方法	756 
	23.6 请求重画	758 
	23.7 使用状态栏窗口	761 
	23.8 HTML APPLET标记	762 
	23.9 向applet传递参数	763 
	23.10 getDocumentBase()和getCodeBase()	766 
	23.11 AppletContext接口和showDocument()方法	767 
	23.12 AudioClip接口	769 
	23.13 AppletStub接口	769 
	23.14 向控制台输出	769 

#### 第24章 事件处理	771 

	24.1 两种事件处理机制	772 
	24.2 委托事件模型	772 
	24.2.1 事件	772 
	24.2.2 事件源	772 
	24.2.3 事件监听器	773 
	24.3 事件类	773 
	24.3.1 ActionEvent类	775 
	24.3.2 AdjustmentEvent类	775 
	24.3.3 ComponentEvent类	776 
	24.3.4 ContainerEvent类	777 
	24.3.5 FocusEvent类	777 
	24.3.6 InputEvent类	778 
	24.3.7 ItemEvent类	779 
	24.3.8 KeyEvent类	779 
	24.3.9 MouseEvent类	780 
	24.3.10 MouseWheelEvent类	782 
	24.3.11 TextEvent类	783 
	24.3.12 WindowEvent类	783 
	24.4 事件源	784 
	24.5 事件监听器接口	784 
	24.5.1 ActionListener接口	785 
	24.5.2 AdjustmentListener接口	785 
	24.5.3 ComponentListener接口	785 
	24.5.4 ContainerListener接口	786 
	24.5.5 FocusListener接口	786 
	24.5.6 ItemListener接口	786 
	24.5.7 KeyListener接口	786 
	24.5.8 MouseListener接口	786 
	24.5.9 MouseMotionListener接口	787 
	24.5.10 MouseWheelListener接口	787 
	24.5.11 TextListener接口	787 
	24.5.12 WindowFocusListener接口	787 
	24.5.13 WindowListener接口	787 
	24.6 使用委托事件模型	788 
	24.6.1 处理鼠标事件	788 
	24.6.2 处理键盘事件	791 
	24.7 适配器类	794 
	24.8 内部类	795 

#### 第25章 AWT介绍：使用窗口、图形和文本	799 

	25.1 AWT类	800 
	25.2 窗口基本元素	802 
	25.2.1 Component类	803 
	25.2.2 Container类	803 
	25.2.3 Panel类	803 
	25.2.4 Window类	803 
	25.2.5 Frame类	803 
	25.2.6 Canvas类	803 
	25.3 使用框架窗口	804 
	25.3.1 设置窗口的尺寸	804 
	25.3.2 隐藏和显示窗口	804 
	25.3.3 设置窗口的标题	804 
	25.3.4 关闭框架窗口	805 
	25.4 在基于AWT的applet中创建框架窗口	805 
	25.5 创建基于窗口的程序	811 
	25.6 在窗口中显示信息	813 
	25.7 使用图形	814 
	25.7.1 绘制直线	814 
	25.7.2 绘制矩形	814 
	25.7.3 绘制椭圆和圆	815 
	25.7.4 绘制弧形	815 
	25.7.5 绘制多边形	815 
	25.7.6 演示绘制方法	815 
	25.7.7 改变图形的大小	817 
	25.8 使用颜色	818 
	25.8.1 Color类的方法	819 
	25.8.2 设置当前图形的颜色	820 
	25.8.3 一个演示颜色的applet	820 
	25.9 设置绘图模式	821 
	25.10 使用字体	823 
	25.10.1 确定可用字体	824 
	25.10.2 创建和选择字体	825 
	25.10.3 获取字体信息	827 
	25.11 使用FontMetrics管理文本输出	828 
	25.11.1 显示多行文本	829 
	25.11.2 居中显示文本	831 
	25.11.3 对齐多行文本	832 

#### 第26章 使用AWT控件、布局管理器和菜单	837 

	26.1 AWT控件的基础知识	838 
	26.1.1 添加和移除控件	838 
	26.1.2 响应控件	839 
	26.1.3 HeadlessException异常	839 
	26.2 使用标签	839 
	26.3 使用命令按钮	840 
	26.4 使用复选框	844 
	26.5 使用复选框组	846 
	26.6 使用下拉列表	847 
	26.7 使用列表框	849 
	26.8 管理滚动条	852 
	26.9 使用TextField	855 
	26.10 使用TextArea	857 
	26.11 理解布局管理器	859 
	26.11.1 FlowLayout布局管理器	859 
	26.11.2 BorderLayout布局管理器	861 
	26.11.3 使用Insets	863 
	26.11.4 GridLayout布局管理器	864 
	26.11.5 CardLayout布局管理器	866 
	26.11.6 GridBagLayout布局管理器	869 
	26.12 菜单栏和菜单	874 
	26.13 对话框	879 
	26.14 FileDialog类	885 
	26.15 关于重写paint()方法	886 

#### 第27章 图像	889 

	27.1 文件格式	890 
	27.2 图像基础：创建、加载与显示	890 
	27.2.1 创建Image对象	890 
	27.2.2 加载图像	891 
	27.2.3 显示图像	891 
	27.3 ImageObserver接口	893 
	27.4 双缓冲	894 
	27.5 MediaTracker类	896 
	27.6 ImageProducer接口	899 
	27.7 ImageConsumer接口	901 
	27.8 ImageFilter类	904 
	27.8.1 CropImageFilter类	904 
	27.8.2 RGBImageFilter类	906 
	27.9 其他图像类	917 

#### 第28章 并发实用工具	919 

	28.1 并发API包	920 
	28.1.1 java.util.concurrent包	920 
	28.1.2 java.util.concurrent.atomic包	921 
	28.1.3 java.util.concurrent.locks包	921 
	28.2 使用同步对象	921 
	28.2.1 Semaphore类	922 
	28.2.2 CountDownLatch类	927 
	28.2.3 CyclicBarrier类	929 
	28.2.4 Exchanger类	932 
	28.2.5 Phaser类	934 
	28.3 使用执行器	941 
	28.3.1 一个简单的执行器示例	942 
	28.3.2 使用Callable和Future接口	944 
	28.4 TimeUnit枚举	947 
	28.5 并发集合	948 
	28.6 锁	949 
	28.7 原子操作	951 
	28.8 通过Fork/Join框架进行并行编程	953 
	28.8.1 主要的Fork/Join类	953 
	28.8.2 分而治之的策略	956 
	28.8.3 一个简单的Fork/Join示例	957 
	28.8.4 理解并行级别带来的影响	960 
	28.8.5 一个使用RecursiveTask[V]的例子	963 
	28.8.6 异步执行任务	965 
	28.8.7 取消任务	966 
	28.8.8 确定任务的完成状态	966 
	28.8.9 重新启动任务	966 
	28.8.10 深入研究	967 
	28.8.11 关于Fork/Join框架的一些提示	968 
	28.9 并发实用工具与Java传统方式的比较	968 

#### 第29章 流API	971 

	29.1 流的基础知识	972 
	29.1.1 流接口	972 
	29.1.2 如何获得流	974 
	29.1.3 一个简单的流示例	975 
	29.2 缩减操作	978 
	29.3 使用并行流	980 
	29.4 映射	983 
	29.5 收集	987 
	29.6 迭代器和流	991 
	29.6.1 对流使用迭代器	991 
	29.6.2 使用Spliterator	992 
	29.7 流API中更多值得探究的地方	995 

#### 第30章 正则表达式和其他包	997 

	30.1 核心Java API包	998 
	30.2 正则表达式处理	1000 
	30.2.1 Pattern类	1000 
	30.2.2 Matcher类	1000 
	30.2.3 正则表达式的语法	1001 
	30.2.4 演示模式匹配	1002 
	30.2.5 模式匹配的两个选项	1007 
	30.2.6 探究正则表达式	1008 
	30.3 反射	1008 
	30.4 远程方法调用	1012 
	30.5 使用java.text格式化日期和时间	1015 
	30.5.1 DateFormat类	1015 
	30.5.2 SimpleDateFormat类	1017 
	30.6 JDK 8新增的时间和日期API	1019 
	30.6.1 时间和日期的基础知识	1020 
	30.6.2 格式化日期和时间	1021 
	30.6.3 解析日期和时间字符串	1024 
	30.7 探究java.time包的其他方面	1025 
	
## 第Ⅲ部分 使用Swing进行 GUI编程 
	

#### 第31章 Swing简介	1029 

	31.1 Swing的起源	1030 
	31.2 Swing以AWT为基础	1030 
	31.3 两个关键的Swing特性	1030 
	31.3.1 Swing组件是轻量级的	1031 
	31.3.2 Swing支持可插入外观	1031 
	31.4 MVC连接	1031 
	31.5 组件与容器	1032 
	31.5.1 组件	1032 
	31.5.2 容器	1033 
	31.5.3 顶级容器窗格	1033 
	31.6 Swing包	1034 
	31.7 一个简单的Swing应用程序	1034 
	31.8 事件处理	1038 
	31.9 创建Swing applet	1041 
	31.10 在Swing中绘图	1044 
	31.10.1 绘图的基础知识	1044 
	31.10.2 计算可绘制区域	1045 
	31.10.3 一个绘图示例	1045 

#### 第32章 探究Swing	1049 

	32.1 JLabel与ImageIcon	1050 
	32.2 JTextField	1051 
	32.3 Swing按钮	1053 
	32.3.1 JButton	1053 
	32.3.2 JToggleButton	1056 
	32.3.3 复选框	1058 
	32.3.4 单选按钮	1060 
	32.4 JTabbedPane	1063 
	32.5 JScrollPane	1065 
	32.6 JList	1067 
	32.7 JComboBox	1070 
	32.8 树	1073 
	32.9 JTable	1076 

#### 第33章 Swing菜单简介	1079 

	33.1 菜单的基础知识	1080 
	33.2 JMenuBar、JMenu和JMenuItem概述	1081 
	33.2.1 JMenuBar	1081 
	33.2.2 JMenu	1082 
	33.2.3 JMenuItem	1083 
	33.3 创建主菜单	1084 
	33.4 向菜单项添加助记符和加速键	1088 
	33.5 向菜单项添加图片和工具提示	1090 
	33.6 使用JRadioButtonMenuItem和JCheckBoxMenuItem	1091 
	33.7 创建弹出菜单	1094 
	33.8 创建工具栏	1096 
	33.9 使用动作	1099 
	33.10 完整演示MenuDemo程序	1104 
	33.11 继续探究Swing	1111 
	
## 第Ⅳ部分 使用JavaFX进行GUI编程 
	

#### 第34章 JavaFX GUI编程简介	1115 

	34.1 JavaFX的基础概念	1116 
	34.1.1 JavaFX包	1116 
	34.1.2 Stage和Scene类	1117 
	34.1.3 节点和场景图	1117 
	34.1.4 布局	1117 
	34.1.5 Application类和生命周期方法	1117 
	34.1.6 启动JavaFX应用程序	1118 
	34.2 JavaFX应用程序的骨架	1118 
	34.3 编译和运行JavaFX程序	1121 
	34.4 应用程序线程	1122 
	34.5 一个简单的JavaFX控件：Label	1122 
	34.6 使用按钮和事件	1124 
	34.6.1 事件的基础知识	1124 
	34.6.2 按钮控件简介	1125 
	34.6.3 演示事件处理和按钮	1125 
	34.7 直接在画布上绘制	1128 

#### 第35章 探究JavaFX控件	1135 

	35.1 使用Image和ImageView	1136 
	35.1.1 向标签添加图片	1138 
	35.1.2 在按钮中使用图片	1140 
	35.2 ToggleButton	1143 
	35.3 RadioButton	1145 
	35.3.1 处理开关组中的变化事件	1149 
	35.3.2 处理单选按钮的另一种方式	1150 
	35.4 CheckBox	1152 
	35.5 ListView	1156 
	35.5.1 ListView的滚动条	1160 
	35.5.2 启用多项选择	1160 
	35.6 ComboBox	1161 
	35.7 TextField	1164 
	35.8 ScrollPane	1167 
	35.9 TreeView	1170 
	35.10 效果和变换简介	1175 
	35.10.1 效果	1175 
	35.10.2 变换	1176 
	35.10.3 演示效果和变换	1177 
	35.11 添加工具提示	1180 
	35.12 禁用控件	1181 

#### 第36章 JavaFX菜单简介	1183 

	36.1 菜单的基础知识	1184 
	36.2 MenuBar、Menu和MenuItem概述	1185 
	36.2.1 MenuBar	1185 
	36.2.2 Menu	1186 
	36.2.3 MenuItem	1186 
	36.3 创建主菜单	1187 
	36.4 向菜单项添加助记符和加速键	1193 
	36.5 向菜单项添加图片	1194 
	36.6 使用RadioMenuItem和CheckMenuItem	1195 
	36.7 创建上下文菜单	1197 
	36.8 创建工具栏	1200 
	36.9 完整的MenuDemo程序	1202 
	36.10 继续探究JavaFX	1209 
	
## 第Ⅴ部分 应用Java 
	

#### 第37章 Java Bean	1213 

	37.1 Java Bean是什么	1214 
	37.2 Java Bean的优势	1214 
	37.3 内省	1214 
	37.3.1 属性的设计模式	1214 
	37.3.2 事件的设计模式	1216 
	37.3.3 方法与设计模式	1216 
	37.3.4 使用BeanInfo接口	1216 
	37.4 绑定属性与约束属性	1217 
	37.5 持久性	1217 
	37.6 定制器	1218 
	37.7 Java Bean API	1218 
	37.7.1 Introspector类	1219 
	37.7.2 PropertyDescriptor类	1220 
	37.7.3 EventSetDescriptor类	1220 
	37.7.4 MethodDescriptor类	1220 
	37.8 一个Bean示例	1220 

#### 第38章 servlet	1225 

	38.1 背景	1225 
	38.2 servelet的生命周期	1226 
	38.3 servlet开发选项	1227 
	38.4 使用Tomcat	1227 
	38.5 一个简单的servlet	1229 
	38.5.1 创建和编译servlet源代码	1229 
	38.5.2 启动Tomcat	1230 
	38.5.3 启动Web浏览器并请求servlet	1230 
	38.6 Servlet API	1230 
	38.7 javax.servlet包	1230 
	38.7.1 Servlet接口	1231 
	38.7.2 ServletConfig接口	1231 
	38.7.3 ServletContext接口	1232 
	38.7.4 ServletRequest接口	1232 
	38.7.5 ServletResponse接口	1233 
	38.7.6 GenericServlet类	1233 
	38.7.7 ServletInputStream类	1234 
	38.7.8 ServletOutputStream类	1234 
	38.7.9 servlet异常类	1234 
	38.8 读取servlet参数	1234 
	38.9 javax.servlet.http包	1236 
	38.9.1 HttpServletRequest接口	1236 
	38.9.2 HttpServletResponse接口	1237 
	38.9.3 HttpSession接口	1238 
	38.9.4 Cookie类	1239 
	38.9.5 HttpServlet类	1240 
	38.10 处理HTTP请求和响应	1241 
	38.10.1 处理HTTP GET请求	1241 
	38.10.2 处理HTTP POST请求	1243 
	38.11 使用cookie	1244 
	38.12 会话跟踪	1246 
	附录 使用Java的文档注释	1249 