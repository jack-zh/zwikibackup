tags: read
title: 《深入Linux内核架构》-目录

## 第1章 简介和概述	1 

 + 1.1 内核的任务	2 
 + 1.2 实现策略	2 
 + 1.3 内核的组成部分	3 
 + 1.3.1 进程、进程切换、调度	3 
 + 1.3.2 UNIX进程	4 
 + 1.3.3 地址空间与特权级别	6 
 + 1.3.4 页表	9 
 + 1.3.5 物理内存的分配	11 
 + 1.3.6 计时	13 
 + 1.3.7 系统调用	13 
 + 1.3.8 设备驱动程序、块设备和字符设备	14 
 + 1.3.9 网络	14 
 + 1.3.10 文件系统	14 
 + 1.3.11 模块和热插拔	15 
 + 1.3.12 缓存	16 
 + 1.3.13 链表处理	16 
 + 1.3.14 对象管理和引用计数	17 
 + 1.3.15 数据类型	20 
 + 1.3.16 本书的局限性	22 
 + 1.4 为什么内核是特别的	23 
 + 1.5 行文注记	23 
 + 1.6 小结	27 

## 第2章 进程管理和调度	28 

 + 2.1 进程优先级	28 
 + 2.2 进程生命周期	30 
 + 2.3 进程表示	32 
 + 2.3.1 进程类型	37 
 + 2.3.2 命名空间	37 
 + 2.3.3 进程ID号	43 
 + 2.3.4 进程关系	49 
 + 2.4 进程管理相关的系统调用	50 
 + 2.4.1 进程复制	50 
 + 2.4.2 内核线程	62 
 + 2.4.3 启动新程序	63 
 + 2.4.4 退出进程	66 
 + 2.5 调度器的实现	67 
 + 2.5.1 概观	67 
 + 2.5.2 数据结构	69 
 + 2.5.3 处理优先级	74 
 + 2.5.4 核心调度器	79 
 + 2.6 完全公平调度类	84 
 + 2.6.1 数据结构	85 
 + 2.6.2 CFS操作	85 
 + 2.6.3 队列操作	89 
 + 2.6.4 选择下一个进程	91 
 + 2.6.5 处理周期性调度器	92 
 + 2.6.6 唤醒抢占	93 
 + 2.6.7 处理新进程	93 
 + 2.7 实时调度类	94 
 + 2.7.1 性质	94 
 + 2.7.2 数据结构	95 
 + 2.7.3 调度器操作	96 
 + 2.8 调度器增强	97 
 + 2.8.1 SMP调度	97 
 + 2.8.2 调度域和控制组	101 
 + 2.8.3 内核抢占和低延迟相关工作	102 
 + 2.9 小结	106 

## 第3章 内存管理	107 

 + 3.1 概述	107 
 + 3.2 (N)UMA模型中的内存组织	109 
 + 3.2.1 概述	109 
 + 3.2.2 数据结构	111 
 + 3.3 页表	123 
 + 3.3.1 数据结构	124 
 + 3.3.2 页表项的创建和操作	129 
 + 3.4 初始化内存管理	129 
 + 3.4.1 建立数据结构	130 
 + 3.4.2 特定于体系结构的设置	135 
 + 3.4.3 启动过程期间的内存管理	153 
 + 3.5 物理内存的管理	159 
 + 3.5.1 伙伴系统的结构	159 
 + 3.5.2 避免碎片	161 
 + 3.5.3 初始化内存域和结点数据结构	167 
 + 3.5.4 分配器API	172 
 + 3.5.5 分配页	177 
 + 3.5.6 释放页	192 
 + 3.5.7 内核中不连续页的分配	195 
 + 3.5.8 内核映射	201 
 + 3.6 slab分配器	205 
 + 3.6.1 备选分配器	206 
 + 3.6.2 内核中的内存管理	207 
 + 3.6.3 slab分配的原理	209 
 + 3.6.4 实现	212 
 + 3.6.5 通用缓存	226 
 + 3.7 处理器高速缓存和TLB控制	228 
 + 3.8 小结	230 

## 第4章 进程虚拟内存	231 

  + 4.1 简介	231 
  + 4.2 进程虚拟地址空间	231 
  + 4.2.1 进程地址空间的布局	232 
  + 4.2.2 建立布局	234 
  + 4.3 内存映射的原理	237 
  + 4.4 数据结构	238 
  + 4.4.1 树和链表	238 
  + 4.4.2 虚拟内存区域的表示	239 
  + 4.4.3 优先查找树	241 
  + 4.5 对区域的操作	244 
  + 4.5.1 将虚拟地址关联到区域	245 
  + 4.5.2 区域合并	246 
  + 4.5.3 插入区域	247 
  + 4.5.4 创建区域	248 
  + 4.6 地址空间	250 
  + 4.7 内存映射	251 
  + 4.7.1 创建映射	251 
  + 4.7.2 删除映射	253 
  + 4.7.3 非线性映射	254 
  + 4.8 反向映射	257 
  + 4.8.1 数据结构	258 
  + 4.8.2 建立逆向映射	259 
  + 4.8.3 使用逆向映射	259 
  + 4.9 堆的管理	261 
  + 4.10 缺页异常的处理	263 
  + 4.11 用户空间缺页异常的校正	268 
  + 4.11.1 按需分配/调页	269 
  + 4.11.2 匿名页	271 
  + 4.11.3 写时复制	271 
  + 4.11.4 获取非线性映射	272 
  + 4.12 内核缺页异常	272 
  + 4.13 在内核和用户空间之间复制数据	274 
  + 4.14 小结	276 

## 第5章 锁与进程间通信	277 

  + 5.1 控制机制	277 
  + 5.1.1 竞态条件	277 
  + 5.1.2 临界区	278 
  + 5.2 内核锁机制	279 
  + 5.2.1 对整数的原子操作	280 
  + 5.2.2 自旋锁	282 
  + 5.2.3 信号量	283 
  + 5.2.4 RCU机制	284 
  + 5.2.5 内存和优化屏障	286 
  + 5.2.6 读者/写者锁	287 
  + 5.2.7 大内核锁	288 
  + 5.2.8 互斥量	288 
  + 5.2.9 近似的per-CPU计数器	290 
  + 5.2.10 锁竞争与细粒度锁	291 
  + 5.3 System V进程间通信	292 
  + 5.3.1 System V机制	292 
  + 5.3.2 信号量	292 
  + 5.3.3 消息队列	300 
  + 5.3.4 共享内存	303 
  + 5.4 其他IPC机制	303 
  + 5.4.1 信号	303 
  + 5.4.2 管道和套接字	310 
  + 5.5 小结	311 

## 第6章 设备驱动程序	312 

  + 6.1 I/O体系结构	312 
  + 6.2 访问设备	316 
  + 6.2.1 设备文件	316 
  + 6.2.2 字符设备、块设备和其他设备	317 
  + 6.2.3 使用ioctl进行设备寻址	319 
  + 6.2.4 主从设备号的表示	320 
  + 6.2.5 注册	321 
  + 6.3 与文件系统关联	324 
  + 6.3.1 inode中的设备文件成员	324 
  + 6.3.2 标准文件操作	325 
  + 6.3.3 用于字符设备的标准操作	325 
  + 6.3.4 用于块设备的标准操作	325 
  + 6.4 字符设备操作	326 
  + 6.4.1 表示字符设备	326 
  + 6.4.2 打开设备文件	326 
  + 6.4.3 读写操作	328 
  + 6.5 块设备操作	329 
  + 6.5.1 块设备的表示	330 
  + 6.5.2 数据结构	331 
  + 6.5.3 向系统添加磁盘和分区	338 
  + 6.5.4 打开块设备文件	339 
  + 6.5.5 请求结构	341 
  + 6.5.6 BIO	343 
  + 6.5.7 提交请求	345 
  + 6.5.8 I/O调度	350 
  + 6.5.9 ioctl的实现	352 
  + 6.6 资源分配	353 
  + 6.6.1 资源管理	353 
  + 6.6.2 I/O内存	355 
  + 6.6.3 I/O端口	357 
  + 6.7 总线系统	358 
  + 6.7.1 通用驱动程序模型	358 
  + 6.7.2 PCI总线	363 
  + 6.7.3 USB	370 
  + 6.8 小结	376 

## 第7章 模块	377 

  + 7.1 概述	377 
  + 7.2 使用模块	378 
  + 7.2.1 添加和移除	378 
  + 7.2.2 依赖关系	380 
  + 7.2.3 查询模块信息	381 
  + 7.2.4 自动加载	382 
  + 7.3 插入和删除模块	384 
  + 7.3.1 模块的表示	385 
  + 7.3.2 依赖关系和引用	389 
  + 7.3.3 模块的二进制结构	391 
  + 7.3.4 插入模块	396 
  + 7.3.5 移除模块	403 
  + 7.4 自动化与热插拔	404 
  + 7.4.1 kmod实现的自动加载	404 
  + 7.4.2 热插拔	405 
  + 7.5 版本控制	408 
  + 7.5.1 校验和方法	408 
  + 7.5.2 版本控制函数	411 
  + 7.6 小结	412 

## 第8章 虚拟文件系统	413 

  + 8.1 文件系统类型	413 
  + 8.2 通用文件模型	414 
  + 8.2.1 inode	415 
  + 8.2.2 链接	416 
  + 8.2.3 编程接口	416 
  + 8.2.4 将文件作为通用接口	417 
  + 8.3 VFS的结构	417 
  + 8.3.1 结构概观	418 
  + 8.3.2 inode	419 
  + 8.3.3 特定于进程的信息	423 
  + 8.3.4 文件操作	427 
  + 8.3.5 目录项缓存	431 
  + 8.4 处理VFS对象	436 
  + 8.4.1 文件系统操作	436 
  + 8.4.2 文件操作	450 
  + 8.5 标准函数	456 
  + 8.5.1 通用读取例程	457 
  + 8.5.2 失效机制	459 
  + 8.5.3 权限检查	461 
  + 8.6 小结	463 

## 第9章 Ext文件系统族	464 

  + 9.1 简介	464 
  + 9.2 Ext2文件系统	465 
  + 9.2.1 物理结构	465 
  + 9.2.2 数据结构	470 
  + 9.2.3 创建文件系统	484 
  + 9.2.4 文件系统操作	485 
  + 9.3 Ext3文件系统	507 
  + 9.3.1 概念	508 
  + 9.3.2 数据结构	509 
  + 9.4 小结	511 

## 第10章 无持久存储的文件系统 512 

  + 10.1 proc文件系统	512 
  + 10.1.1 /proc的内容	513 
  + 10.1.2 数据结构	519 
  + 10.1.3 初始化	522 
  + 10.1.4 装载proc文件系统	523 
  + 10.1.5 管理/proc数据项	525 
  + 10.1.6 读取和写入信息	528 
  + 10.1.7 进程相关的信息	530 
  + 10.1.8 系统控制机制	535 
  + 10.2 简单的文件系统	542 
  + 10.2.1 顺序文件	542 
  + 10.2.2 用libfs编写文件系统	546 
  + 10.2.3 调试文件系统	547 
  + 10.2.4 伪文件系统	549 
  + 10.3 sysfs	549 
  + 10.3.1 概述	550 
  + 10.3.2 数据结构	550 
  + 10.3.3 装载文件系统	554 
  + 10.3.4 文件和目录操作	556 
  + 10.3.5 向sysfs添加内容	562 
  + 10.4 小结	564 

## 第11章 扩展属性和访问控制表	565 

  + 11.1 扩展属性	565 
  + 11.1.1 到虚拟文件系统的接口	566 
  + 11.1.2 Ext3中的实现	570 
  + 11.1.3 Ext2中的实现	576 
  + 11.2 访问控制表	577 
  + 11.2.1 通用实现	577 
  + 11.2.2 Ext3中的实现	580 
  + 11.2.3 Ext2中的实现	585 
  + 11.3 小结	585 

## 第12章 网络	586 

  + 12.1 互联的计算机	586 
  + 12.2 ISO/OSI和TCP/IP参考模型	587 
  + 12.3 通过套接字通信	589 
  + 12.3.1 创建套接字	590 
  + 12.3.2 使用套接字	591 
  + 12.3.3 数据报套接字	595 
  + 12.4 网络实现的分层模型	595 
  + 12.5 网络命名空间	597 
  + 12.6 套接字缓冲区	599 
  + 12.6.1 使用套接字缓冲区管理数据	600 
  + 12.6.2 管理套接字缓冲区数据	602 
  + 12.7 网络访问层	603 
  + 12.7.1 网络设备的表示	603 
  + 12.7.2 接收分组	608 
  + 12.7.3 发送分组	614 
  + 12.8 网络层	615 
  + 12.8.1 IPv4	615 
  + 12.8.2 接收分组	617 
  + 12.8.3 交付到本地传输层	618 
  + 12.8.4 分组转发	619 
  + 12.8.5 发送分组	620 
  + 12.8.6 netfilter	623 
  + 12.8.7 IPv6	627 
  + 12.9 传输层	628 
  + 12.9.1 UDP	628 
  + 12.9.2 TCP	630 
  + 12.10 应用层	640 
  + 12.10.1 socket数据结构	640 
  + 12.10.2 套接字和文件	643 
  + 12.10.3 socketcall系统调用	644 
  + 12.10.4 创建套接字	645 
  + 12.10.5 接收数据	646 
  + 12.10.6 发送数据	647 
  + 12.11 内核内部的网络通信	647 
  + 12.11.1 通信函数	648 
  + 12.11.2 netlink机制	649 
  + 12.12 小结	654 

## 第13章 系统调用	655 

  + 13.1 系统程序设计基础	655 
  + 13.1.1 追踪系统调用	656 
  + 13.1.2 支持的标准	658 
  + 13.1.3 重启系统调用	659 
  + 13.2 可用的系统调用	660 
  + 13.3 系统调用的实现	663 
  + 13.3.1 系统调用的结构	664 
  + 13.3.2 访问用户空间	670 
  + 13.3.3 追踪系统调用	670 
  + 13.4 小结	676 

## 第14章 内核活动	678 

  + 14.1 中断	678 
  + 14.1.1 中断类型	678 
  + 14.1.2 硬件IRQ	680 
  + 14.1.3 处理中断	680 
  + 14.1.4 数据结构	682 
  + 14.1.5 中断电流处理	688 
  + 14.1.6 初始化和分配IRQ	692 
  + 14.1.7 处理IRQ	693 
  + 14.2 软中断	701 
  + 14.2.1 开启软中断处理	702 
  + 14.2.2 软中断守护进程	703 
  + 14.3 tasklet	704 
  + 14.3.1 创建tasklet	704 
  + 14.3.2 注册tasklet	704 
  + 14.3.3 执行tasklet	705 
  + 14.4 等待队列和完成量	706 
  + 14.4.1 等待队列	706 
  + 14.4.2 完成量	710 
  + 14.4.3 工作队列	711 
  + 14.5 小结	713 

## 第15章 时间管理	714 

  + 15.1 概述	714 
  + 15.1.1 定时器的类型	714 
  + 15.1.2 配置选项	716 
  + 15.2 低分辨率定时器的实现	717 
  + 15.2.1 定时器激活与进程统计	717 
  + 15.2.2 处理jiffies	719 
  + 15.2.3 数据结构	720 
  + 15.2.4 动态定时器	721 
  + 15.3 通用时间子系统	725 
  + 15.3.1 概述	726 
  + 15.3.2 配置选项	727 
  + 15.3.3 时间表示	727 
  + 15.3.4 用于时间管理的对象	728 
  + 15.4 高分辨率定时器	736 
  + 15.4.1 数据结构	736 
  + 15.4.2 设置定时器	740 
  + 15.4.3 实现	740 
  + 15.4.4 周期时钟仿真	745 
  + 15.4.5 切换到高分辨率定时器	746 
  + 15.5 动态时钟	747 
  + 15.5.1 数据结构	747 
  + 15.5.2 低分辨率系统下的动态时钟	749 
  + 15.5.3 高分辨率系统下的动态时钟	751 
  + 15.5.4 停止和启动周期时钟	752 
  + 15.6 广播模式	755 
  + 15.7 定时器相关系统调用的实现	756 
  + 15.7.1 时间基准	756 
  + 15.7.2 alarm和setitimer系统调用	757 
  + 15.7.3 获取当前时间	758 
  + 15.8 管理进程时间	759 
  + 15.9 小结	760 

## 第16章 页缓存和块缓存	761 

  + 16.1 页缓存的结构	762 
  + 16.1.1 管理和查找缓存的页	762 
  + 16.1.2 回写修改的数据	763 
  + 16.2 块缓存的结构	764 
  + 16.3 地址空间	766 
  + 16.3.1 数据结构	766 
  + 16.3.2 页树	768 
  + 16.3.3 地址空间操作	771 
  + 16.4 页缓存的实现	774 
  + 16.4.1 分配页	774 
  + 16.4.2 查找页	775 
  + 16.4.3 在页上等待	776 
  + 16.4.4 对整页的操作	777 
  + 16.4.5 页缓存预读	778 
  + 16.5 块缓存的实现	781 
  + 16.5.1 数据结构	782 
  + 16.5.2 操作	783 
  + 16.5.3 页缓存和块缓存的交互	783 
  + 16.5.4 独立的缓冲区	787 
  + 16.6 小结	792 

## 第17章 数据同步	793 

  + 17.1 概述	793 
  + 17.2 pdflush机制	795 
  + 17.3 启动新线程	796 
  + 17.4 线程初始化	796 
  + 17.5 执行实际工作	798 
  + 17.6 周期性刷出	798 
  + 17.7 相关的数据结构	799 
  + 17.7.1 页状态	799 
  + 17.7.2 回写控制	800 
  + 17.7.3 可调参数	802 
  + 17.8 中央控制	802 
  + 17.9 超级块同步	804 
  + 17.10 inode同步	804 
  + 17.10.1 遍历超级块	805 
  + 17.10.2 考察超级块inode	805 
  + 17.10.3 回写单个inode	807 
  + 17.11 拥塞	809 
  + 17.11.1 数据结构	809 
  + 17.11.2 阈值	810 
  + 17.11.3 拥塞状态的设置和清除	811 
  + 17.11.4 在拥塞队列上等待	812 
  + 17.12 强制回写	813 
  + 17.13 膝上模式	814 
  + 17.14 用于同步控制的系统调用	815 
  + 17.15 完全同步	815 
  + 17.15.1 inode的同步	816 
  + 17.15.2 单个文件的同步	818 
  + 17.15.3 内存映射的同步	819 
  + 17.16 小结	820 

## 第18章 页面回收和页交换	821 

  + 18.1 概述	821 
  + 18.1.1 可换出页	822 
  + 18.1.2 页颠簸	822 
  + 18.1.3 页交换算法	823 
  + 18.2 Linux内核中的页面回收和页交换	824 
  + 18.2.1 交换区的组织	824 
  + 18.2.2 检查内存使用情况	825 
  + 18.2.3 选择要换出的页	825 
  + 18.2.4 处理缺页异常	826 
  + 18.2.5 缩减内核缓存	826 
  + 18.3 管理交换区	826 
  + 18.3.1 数据结构	827 
  + 18.3.2 创建交换区	830 
  + 18.3.3 激活交换区	831 
  + 18.4 交换缓存	834 
  + 18.4.1 标识换出页	835 
  + 18.4.2 交换缓存的结构	838 
  + 18.4.3 添加新页	839 
  + 18.4.4 搜索一页	843 
  + 18.5 数据回写	844 
  + 18.6 页面回收	845 
  + 18.6.1 概述	845 
  + 18.6.2 数据结构	847 
  + 18.6.3 确定页的活动程度	850 
  + 18.6.4 收缩内存域	853 
  + 18.6.5 隔离LRU页和集中回收	856 
  + 18.6.6 收缩活动页链表	859 
  + 18.6.7 回收不活动页	862 
  + 18.7 交换令牌	867 
  + 18.8 处理交换缺页异常	870 
  + 18.8.1 换入页	870 
  + 18.8.2 读取数据	872 
  + 18.8.3 交换预读	873 
  + 18.9 发起内存回收	873 
  + 18.9.1 用kswapd进行周期性内存回收	873 
  + 18.9.2 在严重内存不足时换出页	877 
  + 18.10 收缩其他缓存	878 
  + 18.10.1 数据结构	878 
  + 18.10.2 注册和删除收缩器	879 
  + 18.10.3 收缩缓存	879 
  + 18.11 小结	880 

## 第19章 审计	882 

  + 19.1 概述	882 
  + 19.2 审计规则	883 
  + 19.3 实现	884 
  + 19.3.1 数据结构	884 
  + 19.3.2 初始化	889 
  + 19.3.3 处理请求	890 
  + 19.3.4 记录事件	891 
  + 19.3.5 系统调用审计	893 
  + 19.4 小结	898 

## 附录A 体系结构相关知识	899 

  + A.1 概述	899 
  + A.2 数据类型	900 
  + A.3 对齐	900 
  + A.4 内存页面	900 
  + A.5 系统调用	901 
  + A.6 字符串处理	901 
  + A.7 线程表示	902 
  + A.8 位操作和字节序	914 
  + A.9 页表	916 
  + A.10 杂项	916 
  + A.11 小结	918 

## 附录B 使用源代码	919 

  + B.1 内核源代码的组织	919 
  + B.2 用Kconfig进行配置	920 
  + B.3 用Kbuild编译内核	930 
  + B.4 有用的工具	935 
  + B.5 调试和分析内核	942 
  + B.6 用户模式Linux	945 
  + B.7 小结	946 

## 附录C 有关C语言的注记	947 

  + C.1 GNU C编译器如何工作	947 
  + C.2 内核的标准数据结构和技术	967 
  + C.3 小结	984 

## 附录D 系统启动	985 

  + D.1 IA-32系统上与体系结构相关的设置	985 
  + D.2 高层初始化	986 
  + D.3 小结	998 

## 附录E ELF二进制格式	999 

  + E.1 布局和结构	999 
  + E.2 内核中的数据结构	1006 
  + E.3 小结	1018 

## 附录F 内核开发过程	1019 

  + F.1 简介	1019 
  + F.2 内核代码树和开发的结构	1019 
  + F.3 补丁的结构	1024 
  + F.4 Linux和学术界	1030 
  + F.5 小结	1035 
