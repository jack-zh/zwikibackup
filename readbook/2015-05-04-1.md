title: 《深度实践嵌入式Linux系统移植 》-目录
tags: read

## 绪论篇

### 1章嵌入式系统架构与移植环境搭建2
	1.1　嵌入式系统硬件架构2
	1.1.1　微处理器3
	1.1.2　总线4
	1.1.3　存储器5
	1.2　嵌入式系统软件架构6
	1.3　嵌入式Linux移植环境搭建7
	1.3.1　Ubuntu开发平台7
	1.3.2　搭建交叉编译环境8
	1.3.3　获取内核9
	1.3.4　获取启动加载器9
	1.3.5　配置必要服务9
	1.3.6　PuTTY的安装和配置12
	1.4　本章小结12

## u-boot移植篇

### 2章u-boot工程与编译系统14
	2.1　u-boot介绍14
	2.1.1　u-boot工程简介15
	2.1.2　u-boot源码结构15
	2.1.3　u-boot的配置编译16
	2.2　u-boot常用命令与测试18
	2.2.1　获取帮助18
	2.2.2　环境变量相关命令19
	2.2.3　网络命令20
	2.2.4　Nand Flash操作命令21
	2.2.5　内存/寄存器相关命令22
	2.2.6　系统引导命令24
	2.3　u-boot编译过程分析25
	2.3.1　主机构建环境配置过程25
	2.3.2　目标机相关配置过程27
	2.3.3　make命令执行过程31
	2.4　本章小结40

### ３章u-boot启动流程分析41
	3.1　u-boot启动第一阶段流程41
	3.1.1　设置异常向量42
	3.1.2　CPU进入SVC模式43
	3.1.3　设置控制寄存器地址43
	3.1.4　关闭看门狗43
	3.1.5　屏蔽中断43
	3.1.6　设置MPLLCON、UPLLCON和CLKDIVN44
	3.1.7　关闭MMU和cache45
	3.1.8　初始化存储控制器46
	3.1.9　复制u-boot第二阶段代码到RAM47
	3.1.10　设置栈48
	3.1.11　清除BSS段48
	3.1.12　跳转到第二阶段代码入口48
	3.2　u-boot启动第二阶段代码分析49
	3.2.1　gd_t结构体49
	3.2.2　bd_t结构体50
	3.2.3　init_sequence数组50
	3.2.4　start_armboot()顺序分析51
	3.2.5　main_loop函数分析52
	3.3　本章小结56

### 4章ARM9/S3C2440 u-boot移植实战57
	4.1　移植准备工作57
	4.1.1　开发环境介绍57
	4.1.2　删减u-boot文件58
	4.1.3　建立My2440配置59
	4.1.4　配置和编译u-boot60
	4.2　u-boot芯片级移植61
	4.2.1　启动代码结构优化61
	4.2.2　系统时钟移植65
	4.2.3　存储器控制器设置68
	4.2.4　在u-boot工程中全面支持CONFIG_S3C2440宏配置69
	4.3　u-boot调试方法探索70
	4.3.1　通过LED指示运行状态70
	4.3.2　在第一阶段的代码中添加打印调试方法72
	4.3.3　在内存中加载和运行u-boot78
	4.4　Nor Flash驱动移植78
	4.4.1　Nor Flash的工作模式78
	4.4.2　Nor Flash的存储结构79
	4.4.3　Nor Flash的硬件连接79
	4.4.4　Nor Flash的操作方法80
	4.4.5　Nor Flash驱动分析83
	4.4.6　Nor Flash驱动移植86
	4.4.7　Nor Flash命令测试87
	4.4.8　完善u-boot的命令行功能88
	4.5　DM9000驱动移植89
	4.5.1　DM9000网卡端口访问90
	4.5.2　DM9000网卡时序分析90
	4.5.3　DM9000网卡驱动分析93
	4.5.4　DM9000网卡驱动移植100
	4.5.5　网卡驱动测试103
	4.5.6　通过TFTP下载程序到内存运行103
	4.6　u-boot启动内核105
	4.6.1　ARM架构的Linux内核启动105
	4.6.2　内核标记列表106
	4.6.3　u-boot启动命令分析1—go命令109
	4.6.4　u-boot启动命令分析2—bootm命令110
	4.6.5　u-boot启动命令的配置与移植115
	4.7　Nand Flash与驱动移植118
	4.7.1　Nand Flash启动原理118
	4.7.2　Nand Flash硬件特性119
	4.7.3　Linux MTD子系统121
	4.7.4　Nand Flash初始化流程分析123
	4.7.5　Nand Flash命令实现分析125
	4.7.6　页读取操作详解127
	4.7.7　Nor Flash和Nand Flash启动自动判断132
	4.7.8　Nand Flash拷贝代码实现132
	4.7.9　Nand Flash板级驱动移植136
	4.7.10　Nand Flash命令测试140
	4.8　YAFFS文件系统移植142
	4.8.1　YAFFS文件系统142
	4.8.2　YAFFS在Nand Flash上的存储结构142
	4.8.3　YAFFS在内存中的组织结构143
	4.8.4　在u-boot中添加对烧写YAFFS镜像的支持144
	4.8.5　YAFFS文件系统镜像制作150
	4.8.6　YAFFS的烧写与测试152
	4.9　UBIFS文件系统移植153
	4.9.1　UBI层153
	4.9.2　UBIFS介绍155
	4.9.3　在u-boot中添加对UBIFS的支持156
	4.9.4　制作UBIFS文件系统镜像157
	4.9.5　UBIFS的烧写与测试158
	4.10　SD卡驱动移植162
	4.10.1　MMC/SD/SDIO介绍162
	4.10.2　SD/MMC协议162
	4.10.3　S3C2440 SDI控制器操作166
	4.10.4　SD卡驱动分析168
	4.10.5　SD卡驱动移植173
	4.11　USB驱动移植176
	4.11.1　USB概述176
	4.11.2　USB系统架构177
	4.11.3　USB的通信方法180
	4.11.4　USB的描述符184
	4.11.5　USB设备请求188
	4.11.6　USB设备枚举191
	4.11.7　S3C2440 USB设备控制器195
	4.11.8　u-boot USB设备控制器驱动分析196
	4.11.9　USB设备驱动移植206
	4.11.10　USB驱动移植210
	4.11.11　USB功能测试214
	4.12　u-boot一键式菜单实现215
	4.12.1　一键式菜单需求分析215
	4.12.2　一键式菜单测试步骤216
	4.12.3　一键式菜单源码分析220
	4.13　本章小结224

### 5章ARM11/S3C6410 u-boot移植实战225
	5.1　移植准备工作225
	5.1.1　开发环境225
	5.1.2　删减u-boot文件226
	5.1.3　建立My6410配置227
	5.1.4　配置和编译u-boot228
	5.2　u-boot芯片级移植229
	5.2.1　修改第一阶段启动代码start.S229
	5.2.2　板级底层初始化文件lowlevel_init.S移植233
	5.2.3　时钟初始化函数移植239
	5.2.4　内存初始化函数实现243
	5.2.5　Nand Flash复制代码实现246
	5.2.6　SD卡复制代码实现250
	5.2.7　底层调试方法探索254
	5.2.8　完善My6410的板级配置258
	5.2.9　烧写与测试265
	5.3　DM9000驱动移植267
	5.3.1　DM9000网卡端口访问267
	5.3.2　DM9000网卡时序分析268
	5.3.3　DM9000网卡驱动移植270
	5.3.4　网卡驱动测试274
	5.4　u-boot启动内核274
	5.4.1　u-boot启动命令的配置与移植275
	5.4.2　修改go命令以支持zImage格式镜像的启动277
	5.5　Nand Flash驱动移植278
	5.5.1　将u-boot下载到内存中运行278
	5.5.2　Nand Flash驱动移植279
	5.5.3　Nand Flash命令测试289
	5.6　YAFFS文件系统移植291
	5.6.1　在u-boot中添加对烧写YAFFS镜像的支持291
	5.6.2　YAFFS文件系统镜像制作298
	5.6.3　YAFFS的烧写与测试299
	5.7　UBIFS文件系统移植300
	5.7.1　在u-boot中添加对UBIFS的支持300
	5.7.2　UBIFS文件系统镜像制作302
	5.7.3　UBIFS的烧写与测试303
	5.8　SD卡驱动移植307
	5.8.1　S3C6410 主机控制器操作307
	5.8.2　S3C6410 主机控制器操作序列308
	5.8.3　SD卡驱动分析310
	5.8.4　SD卡驱动移植317
	5.8.5　通过SD卡更新系统319
	5.9　USB驱动移植321
	5.9.1　S3C6410 USB2.0高速OTG321
	5.9.2　u-boot USB设备控制器驱动分析323
	5.9.3　USB设备驱动移植332
	5.9.4　USB功能测试335
	5.10　本章小结336

## Linux内核移植篇

### 6章Linux内核工程与编译系统338
	6.1Linux内核架构338
	6.1.1内核体系结构338
	6.1.2内核组件339
	6.1.3内核目录结构340
	6.2　Linux内核的配置与编译341
	6.2.1　配置内核341
	6.2.2编译内核344
	6.3Linux内核构建系统345
	6.3.1内核配置过程345
	6.3.2扩展内核代码347
	6.3.3内核中的Makefile348
	6.3.4内核中的Kconfig349
	6.4内核调试技术352
	6.4.1调试准备352
	6.4.2内核调试配置选项352
	6.4.3源码级别的调试接口353
	6.4.4使用printk()打印调试信息355
	6.4.5使用strace跟踪系统调用357
	6.4.6使用OOPS调试系统故障358
	6.5本章小结360

### 7章Linux内核启动流程分析361
	7.1内核镜像生成361
	7.2内核启动流程1——汇编部分362
	7.2.1内核启动代码入口362
	7.2.2深入源码分析363
	7.2.3汇编启动代码分析总结378
	7.3内核启动流程2—C语言部分378
	7.3.1start_kernel()函数379
	7.3.2rest_init()函数388
	7.3.3　kernel_init()函数390
	7.3.4init_post()函数391
	7.4内核启动流程3—Busybox的init进程393
	7.4.1init进程启动流程393
	7.4.2添加初始化活动394
	7.4.3执行初始化活动395
	7.5本章小结396

### 8章Linux移植准备及最小系统构建397
	8.1移植准备工作397
	8.1.1　开发环境397
	8.1.2删减Linux文件398
	8.1.3建立My2440配置400
	8.1.4　建立My6410配置403
	8.1.5编译测试406
	8.2　最小系统搭建409
	8.2.1　嵌入式根文件系统制作409
	8.2.2安装initramfs根文件系统412
	8.3本章小结414

### 9章Linux网卡驱动移植415
	9.1Linux网络子系统415
	9.2　核心数据结构416
	9.2.1　net_device结构416
	9.2.2　sk_buff结构419
	9.3　DM9000网卡驱动分析421
	9.3.1　board_info结构422
	9.3.2　dm9000_probe()函数423
	9.3.3　dm9000_open()函数427
	9.3.4　dm9000_start_xmit()函数427
	9.3.5　数据包接收函数428
	9.3.6　数据包发送函数429
	9.3.7　中断处理函数431
	9.4My2440网卡驱动移植432
	9.4.1　添加DM9000的平台设备432
	9.4.2　在内核配置添加对DM9000的支持434
	9.5　My6410网卡驱动移植434
	9.5.1　添加DM9000的平台设备434
	9.5.2　在内核配置中添加对网络子系统的支持435
	9.5.3　在内核配置添加对DM9000的支持436
	9.6安装NFS根文件系统436
	9.6.1在内核配置添加对NFS的支持436
	9.6.2挂载NFS根文件系统437
	9.7　制作基于共享库的根文件系统437
	9.8本章小结439

### 10章Linux混杂设备驱动440
	10.1　My2440 RTC驱动移植440
	10.2My6410 RTC驱动移植441
	10.2.1修改RTC驱动rtc-s3c.c441
	10.2.2完善对6410 RTC驱动的平台支持445
	10.2.3　在机器配置文件中添加RTC设备448
	10.2.4　在内核中配置RTC448
	10.3　RTC驱动测试449
	10.4为My2440添加ADC和按键驱动451
	10.4.1按键驱动分析451
	10.4.2　在内核中添加ADC和按键驱动454
	10.5　为My6410添加ADC驱动457
	10.6　本章小结458

### 11章Linux I2C驱动移植459
	11.1　I2C协议概述459
	11.1.1　I2C总线物理拓扑结构459
	11.1.2　I2C通信协议460
	11.2Linux I2C子系统框架461
	11.3　I2C驱动中的数据结构及操作462
	11.3.1　i2c_adapter结构462
	11.3.2　i2c_algorithm结构464
	11.3.3　i2c_msg结构464
	11.3.4i2c_driver结构465
	11.3.5　i2c_client结构467
	11.4I2C适配器的设备接口468
	11.4.1　i2cdev_open()函数471
	11.4.2　i2cdev_ read()函数471
	11.4.3　i2cdev_ioctl()函数472
	11.5　S3C2440（6410） I2C适配器驱动的实现473
	11.5.1　S3C2440 I2C platform总线匹配474
	11.5.2　S3C2440 I2C总线驱动描述结构474
	11.5.3　probe方法的实现476
	11.5.4　S3C2440 I2C总线通信方法477
	11.6　S3C2440（6410） I2C适配器驱动移植480
	11.6.1　添加 I2C平台设备480
	11.6.2　在内核配置中支持I2C驱动481
	11.6.3编写I2C总线驱动测试程序482
	11.7S3C2440（6410） I2C设备驱动的实现484
	11.7.1　At24系列I2C EEPROM设备驱动的实现484
	11.7.2传统只读EEPROM设备驱动的实现486
	11.8　I2C EEPROM设备驱动移植489
	11.9本章小结490

### 12章Linux SPI驱动移植491
	12.1SPI协议概述491
	12.1.1　SPI总线物理拓扑结构491
	12.1.2　时钟极性和时钟相位492
	12.1.3　SPI的优缺点493
	12.2　Linux SPI子系统493
	12.3　SPI驱动中的数据结构及操作494
	12.3.1　spi_master结构494
	12.3.2　spi_driver结构495
	12.3.3　spi_device结构496
	12.3.4　spi_message结构497
	12.3.5spi_bitbang结构498
	12.4SPI控制器的设备接口500
	12.5　S3C2440 SPI控制器驱动的实现503
	12.5.1　S3C2440 SPI platform总线匹配503
	12.5.2　S3C2440 SPI控制器驱动描述结构504
	12.5.3　probe方法的实现504
	12.5.4　S3C2440 SPI总线通信方法505
	12.6S3C6410 SPI控制器驱动的实现507
	12.6.1　S3C6410 SPI控制器驱动描述结构507
	12.6.2　probe方法的实现507
	12.6.3　S3C6410 SPI总线通信方法509
	12.7S3C2440 SPI 控制器驱动移植510
	12.7.1在机器配置文件中添加对SPI的支持510
	12.7.2　扩展Kconfig512
	12.7.3在内核配置中支持SPI驱动513
	12.7.4SPI驱动测试513
	12.8S3C6410 SPI 控制器驱动移植513
	12.8.1　添加6410的SPI驱动514
	12.8.2　添加SPI平台设备514
	12.8.3添加6410 DMA平台代码516
	12.8.4　添加SPI、DMA相关的时钟资源518
	12.8.5在机器配置文件中添加对SPI的支持519
	12.8.6　SPI驱动测试521
	12.9　S3C2440（S3C6410） SPI协议驱动移植521
	12.9.1　AT25系列SPI EEPROM协议驱动的实现521
	12.9.2SPI EEPROM设备驱动移植523
	12.10　本章小结524

### 13章Nand Flash驱动移植525
	13.1　Linux MTD子系统525
	13.2　MTD子系统中的数据结构及操作526
	13.2.1　mtd_info结构526
	13.2.2mtd_notifier结构528
	13.2.3　mtd_part/mtd_partitions结构528
	13.3　MTD块设备实现分析530
	13.4　Nand Flash驱动的实现534
	13.4.1　Nand Flash platform总线匹配534
	13.4.2　S3C2440 Nand Flash控制器驱动描述结构534
	13.4.3　probe方法的实现536
	13.4.4　S3C2440 Nand Flash读写方法分析537
	13.5S3C2440 Nand Flash控制器驱动移植538
	13.5.1　在机器配置文件中添加对Nand Flash的支持538
	13.5.2　完善S3C2440的Nand Flash驱动540
	13.5.3　在内核配置中支持 Nand Flash驱动541
	13.6S3C6410 Nand Flash控制器驱动移植541
	13.6.1添加6410 Nand Flash驱动541
	13.6.2添加Nand Flash平台设备542
	13.6.3在机器配置文件中添加对Nand Flash的支持544
	13.6.4　其他修改545
	13.7　YAFFS2文件系统移植547
	13.7.1将YAFFS2文件系统移植到Linux内核548
	13.7.2　利用mtd-utils烧写YAFFS2文件系统镜像548
	13.8　在内核中配置对UBIFS的支持550
	13.9　本章小结550

### 14章SD/MMC卡驱动移植551
	14.1Linux MMC子系统551
	14.2　MMC子系统中的数据结构及操作552
	14.2.1　mmc_host结构552
	14.2.2　mmc_card结构554
	14.2.3mmc_driver结构555
	14.2.4　mmc_request结构556
	14.3卡探测过程分析558
	14.4　S3C2440 SD/MMC主控制器驱动的实现561
	14.4.1　SD/MMC主控制器驱动platform总线匹配561
	14.4.2　S3C2440 SD/MMC主控制器驱动描述结构561
	14.4.3　probe方法的实现563
	14.4.4　S3C2440 SD/MMC主控制器请求处理分析565
	14.5S3C6410 高速MMC控制器驱动的实现568
	14.5.1　SDHCI驱动框架569
	14.5.2SDHCI主机卡探测过程569
	14.5.3S3C6410 HSMMC控制器驱动570
	14.5.4　S3C6410 HSMMC控制器请求处理572
	14.6S3C2440 SD/MMC主机控制器驱动移植572
	14.6.1　在机器配置文件中添加对SD/MMC主控制器的支持572
	14.6.2　在内核配置中添加对SD/MMC主控制器驱动的支持573
	14.6.3在内核配置中添加对中文字符集和FAT文件系统的支持574
	14.6.4在文件系统中添加对热插拔事件处理的支持574
	14.6.5SD/MMC主控制器驱动测试575
	14.7　S3C6410 HSMMC控制器驱动移植576
	14.7.1　添加6410 Nand Flash驱动576
	14.7.2在机器配置文件中添加对HSMMC的支持577
	14.7.3　修改内核SDHCI驱动578
	14.8本章小结579

### 15章LCD驱动移植580
	15.1LCD硬件原理580
	15.1.1　LCD的硬件构成580
	15.1.2TFT屏显示时序581
	15.2　Linux帧缓冲子系统582
	15.3　帧缓冲子系统中的数据结构及操作583
	15.3.1　fb_info结构583
	15.3.2fb_var_screeninfo结构和fb_fix_screeninfo结构587
	15.3.3fb_cmap结构589
	15.4　帧缓冲字符设备接口590
	15.5Linux显示启动Logo594
	15.6S3C2440帧缓冲驱动的实现596
	15.6.1S3C2440 LCD控制器硬件描述596
	15.6.2　驱动platform总线匹配597
	15.6.3　S3C2440 帧缓冲驱动描述结构598
	15.6.4　probe方法实现599
	15.7S3C6410 帧缓冲驱动的实现601
	15.8　S3C2440 帧缓冲驱动移植601
	15.8.1　在板级初始化文件中添加对帧缓冲的支持601
	15.8.2修改Makefile和Kconfig605
	15.8.3　在内核配置中添加对帧缓冲驱动的支持607
	15.8.4　帧缓冲驱动测试608
	15.9　S3C6410 帧缓冲驱动移植608
	15.9.1　添加6410 帧缓冲驱动608
	15.9.2　在机器配置文件中添加对帧 缓冲的支持609
	15.9.3　帧缓冲驱动测试611
	15.10　本章小结611

### 16章触摸屏驱动移植612
	16.1　Linux输入子系统612
	16.2　输入子系统中的数据结构及操作613
	16.2.1　input_dev结构613
	16.2.2　input_handler结构616
	16.2.3　input_handle结构617
	16.3　输入子系统核心层的实现618
	16.4　通用事件处理驱动622
	16.5　输入事件报告流程626
	16.6　S3C2440（6410）触摸屏驱动的分析629
	16.6.1　模块初始化函数的实现629
	16.6.2　中断处理与事件上报630
	16.7　S3C2440触摸屏驱动移植与测试632
	16.7.1　S3C2440触屏驱动移植632
	16.7.2　S3C2440触屏驱动测试633
	16.8　S3C6410触摸屏驱动移植与测试634
	16.8.1　添加6410的触摸屏驱动634
	16.8.2添加触屏平台设备635
	16.8.3　在机器配置文件中添加对触屏的支持636
	16.9　本章小结637

### 17章声卡驱动移植638
	17.1　ALSA体系架构638
	17.1.1　ALSA设备文件639
	17.1.2　驱动代码的文件结构640
	17.2　声卡描述结构snd_card640
	17.3　PCM功能子层644
	17.3.1　PCM的概念644
	17.3.2　PCM设备描述结构snd_pcm645
	17.3.3　PCM流与PCM子流646
	17.3.4　PCM功能子层逻辑关系小结651
	17.3.5　PCM设备文件的建立652
	17.3.6　PCM设备文件的访问654
	17.4　声卡控制项655
	17.4.1　控制项创建655
	17.4.2　控制项回调函数657
	17.4.3　Control设备建立658
	17.5　ASoC声卡驱动架构659
	17.6　ASoC架构中的Machine驱动662
	17.6.1　创建ASoC声卡平台设备662
	17.6.2　ASoC声卡的平台驱动665
	17.7ASoC架构中的Codec驱动666
	17.7.1　Codec的DAI和PCM的配置666
	17.7.2　Codec的控制IO669
	17.7.3　混音器和其他音频控制项671
	17.7.4　Codec设备与ASoC声卡注册673
	17.8　ASoC架构中的Platform驱动676
	17.8.1CPU DAI驱动676
	17.8.2　音频DMA驱动677
	17.8.3　创建音频DMA缓冲区678
	17.8.4　音频DMA的PCM操作681
	17.9　S3C2440+UDA1341声卡驱动配置与测试683
	17.9.1　在机器配置文件中添加对声卡的支持683
	17.9.2　在内核配置中支持声卡驱动684
	17.9.3　应用层alsa-lib移植685
	17.9.4　编写ALSA应用程序686
	17.9.5　播放和录音测试690
	17.10S3C6410+WM9714声卡驱动移植691
	17.10.1添加6410声卡驱动691
	17.10.2在内核配置中支持声卡驱动692
	17.10.3　alsa-utils工具集移植692
	17.11　本章小结693

### 18章USB驱动移植694
	18.1USB子系统架构694
	18.2USB驱动中的描述符结构695
	18.3USB主机驱动695
	18.3.1主机控制器驱动695
	18.3.2OHCI主机控制器驱动698
	18.4S3C2440/S3C6410 USB主机驱动的实现700
	18.5USB设备驱动701
	18.5.1USB设备驱动描述结构702
	18.5.2USB请求块URB703
	18.5.3URB的处理流程705
	18.5.4　usb_bulk_msg()和usb_control_msg()708
	18.5.5探测和断开函数709
	18.6USB骨架程序710
	18.7USB设备驱动实例718
	18.7.1DNW驱动的实现718
	18.7.2USB键盘驱动的实现720
	18.8本章小结728

## 应用程序移植篇

### 19章嵌入式Qt移植730
	19.1Qt开发环境搭建与使用 730
	19.1.1Qt SDK的下载与安装730
	19.1.2第一个Qt程序732
	19.1.3利用Qt Creator建立一个工程733
	19.2Qt的功能模块与裁剪735
	19.2.1Qt模块的构成735
	19.2.2图形用户界面736
	19.2.3信号与槽 736
	19.2.4布局管理737
	19.2.5主视窗737
	19.3嵌入式Qt移植与测试737
	19.3.1触屏库tslib移植737
	19.3.2Qt库移植739
	19.3.3嵌入式Qt程序测试741
	19.3.4嵌入式Qt工程配置与测试743
	19.4本章小结751

### 20章嵌入式多媒体程序移植752
	20.1音频播放程序madplay的移植752
	20.1.1在Ubuntu中安装madplay752
	20.1.2　在Ubuntu中测试madplay753
	20.1.3将madplay移植到开发板753
	20.1.4在开发板中测试madplay755
	20.2视频播放程序MPlayer的移植755
	20.2.1在Ubuntu中安装MPlayer755
	20.2.2在Ubuntu中测试MPlayer756
	20.2.3将MPlayer移植到开发板756
	20.2.4在开发板中测试MPlayer758
	20.3利用Qt开发视频播放器758
	20.3.1MPlayer的SLAVE模式759
	20.3.2示例播放器MyPlayer的实现759
	20.4本章小结760

### 21章嵌入式数据库移植761
	21.1SQLite数据库的使用761
	21.1.1使用命令行操作SQLite761
	21.1.2使用C语言操作SQLite763
	21.1.3在Qt中操作SQLite765
	21.1.4在QTableView中显示数据库内容767
	21.2SQLite数据库的移植770
	21.2.1将SQLite移植到开发板770
	21.2.2在开发板中测试SQLite771
	21.3本章小结773

### 22章嵌入式Web服务器移植774
	22.1Boa的使用与HTML页面测试774
	22.2CGI程序测试779
	22.2.1CGI的概念和原理779
	22.2.2编写CGI脚本测试779
	22.2.3CGIC库的基本使用780
	22.3通过网页控制设备782
	22.4通过网页监控设备785
	22.5网页视频监控788
	22.6将Web服务器移植到开发板791
	22.6.1将Boa移植到开发板791
	22.6.2将CGIC移植到开发板792
	22.6.3将mjpg-streamer移植到开发板792
	22.6.4在开发板上搭建Web服务站点793
	22.7本章小结793

### 23章嵌入式JVM移植794
	23.1phoneME虚拟机移植794
	23.1.1获取源代码795
	23.1.2编译和安装795
	23.1.3测试步骤796
	23.2JamVM虚拟机移植798
	23.2.1GNU Classpath移植798
	23.2.2JamVM移植799
	23.2.3JamVM测试799
	23.3在JamVM上运行Jetty服务器800
	23.3.1Jetty服务器启动800
	23.3.2在Jetty服务器中部署Web应用801
	23.3.3Servlet和JSP页面测试803
	23.4本章小结805 
