tags: read
title: 《ZeroMQ：云时代极速消息通信库》-目录

## 第1 部分 学习如何使用φMQ 来开展工作


### 第1 章 基础知识 3

	修复这个世界 3
	本书的读者对象 5
	获取示例 5
	问过就必有收获 5
	在字符串上的小注解 10
	版本报告 12
	获得消息 12
	分而治之 16
	用φMQ 编程 21
	获取正确的上下文 22
	执行彻底的退出 22
	为什么我们需要φMQ 23
	套接字的可扩展性 27
	从φMQ v2.2 升级到φMQ v3.2 28
	警告：不稳定的典范！ 29

### 第2 章 套接字和模式 31

	套接字API 32
	把套接字接入网络拓扑 32
	使用套接字来传输数据 34
	单播传输 35
	φMQ 不是一个中性载体 35
	I/O 线程 36
	消息传递模式 37
	高级别消息传递模式 38
	处理消息 38
	处理多个套接字 41
	多部分消息 44
	中间层及代理 45
	动态发现问题 46
	共享队列（DEALER 和ROUTER 套接字） 48
	φMQ 的内置代理功能 53
	传输桥接 55
	处理错误和ETERM 56
	处理中断信号 61
	检测内存泄漏 63
	使用φMQ 编写多线程程序 64
	线程间信令（PAIR 套接字） 69
	节点协调 71
	零拷贝 75
	发布- 订阅消息封包 76
	高水位标记 78
	消息丢失问题的解决方案 80

### 第3 章 高级请求- 应答模式 83

	请求- 应答机制 83
	简单的应答封包 84
	扩展的应答封包 84
	这有什么好处呢 87
	请求- 应答套接字回顾 88
	请求- 应答组合 88
	REQ 到REP 组合 89
	DEALER 到REP 组合 89
	REQ 到ROUTER 组合 90
	DEALER 到ROUTER 组合 90
	DEALER 到DEALER 组合 90
	ROUTER 到ROUTER 组合 90
	无效组合 91
	探索ROUTER 套接字 91
	身份和地址 92
	ROUTER 错误处理 .93
	负载均衡模式 94
	ROUTER 代理和REQ 工人 95
	ROUTER 代理及DEALER 工人 97
	负载均衡的消息代理 98
	用于φMQ 的一个高级别的API 105
	高级别API 的特点 107
	CZMQ 高级别API 108
	异步客户端/ 服务器模式 115
	能够工作的示例：跨代理路由 120
	建立详情 120
	单集群架构 121
	扩展到多个集群 122
	联盟与对等比较 124
	命名规范 126
	状态流原型 127
	本地流和云端流原型 130
	总结 137

### 第4 章 可靠的请求- 应答模式 147

	什么是“可靠性” 147
	可靠性设计 148
	客户端可靠性（懒惰海盗模式） 149
	基本可靠队列（简单海盗模式） 154
	健壮的可靠队列（偏执海盗模式） 157
	信号检测 166
	置若罔闻地将它关闭 166
	单向信号检测 167
	乒乓信号检测 167
	针对偏执海盗的信号检测 168
	合同和协议 170
	面向服务的可靠队列（管家模式） 170
	异步管家模式 195
	服务发现 201
	幂等服务 203
	断开连接的可靠性（泰坦尼克模式） 203
	高可用性对（双星模式） 216
	详细需求 218
	避免脑裂症状 220
	双星实现 221
	双星反应器 228
	无代理可靠性（自由职业者模式） 234
	模型一：简单的重试和故障转移 235
	模型二：粗暴猎枪屠杀 238
	模式三：复杂和讨厌的 244
	结论 256

### 第5 章 高级发布- 订阅模式 257

	发布- 订阅模式的优点和缺点 257
	发布- 订阅跟踪（特浓咖啡模式） 259
	最后一个值缓存 262
	慢速订阅者检测（自杀蜗牛模式） 267
	高速订阅者（黑盒模式） 270
	可靠的发布- 订阅（克隆模式） 272
	集中式与分散式 273
	将状态表示为键- 值对 273
	得到带外的快照 284
	重新发布来自客户端的更新 290
	处理子树 295
	临时值 298
	使用反应器 306
	在双星模式中添加可靠性 311
	集群的散列映射协议 321
	构建一个多线程栈和API 325

## 第2 部分 使用φMQ 的软件工程


### 第6 章 φMQ 社区 341

	φMQ 社区的架构 342
	如何制作真正的大型架构 343
	软件架构的心理学 344
	合同 346
	过程 348
	疯狂，美丽，并且容易 348
	陌生人，遇见陌生人 349
	无限的财富 349
	照管和培育 350
	φMQ 过程：C4 351
	语言 351
	目标 352
	热身 354
	许可和所有权 355
	对补丁程序的要求 356
	开发过程 357
	建立稳定的版本 361
	公共合同的演变 362
	一个实际例子 364
	Git 分支是有害的 368
	简单性与复杂性的对比 369
	更改延迟 369
	学习曲线 369
	出故障的成本 369
	前期协调 369
	可扩展性 370
	惊奇和期望 370
	参与的经济学 370
	在冲突中的强壮性 370
	隔离的保证 370
	能见度 371
	结论 371
	为创新而设计 371
	双桥传说 371
	φMQ 的路线图是如何失去的 372
	垃圾桶化的设计 374
	复杂化的设计 376
	简约化的设计 377
	职业倦怠 379
	成功模式 380
	懒惰的完美主义者 381
	仁慈暴君 381
	天和地 381
	门户开放 381
	大笑的小丑 382
	留心的将军 382
	社会工程师 382
	不朽的园丁 382
	滚石 382
	海盗帮 383
	快闪族 383
	加那利看守 383
	执行绞刑的刽子手 383
	历史学家 383
	煽动者 384
	神秘人 384

### 第7 章 使用φMQ 的高级架构 385

	用于弹性设计的面向消息模式 386
	第1 步：内部化的语义 387
	第2 步：描绘一个粗略的架构 387
	第3 步：决定合同 388
	第4 步：编写一个最小的端到端解决方案 388
	第5 步：解决一个问题，然后重复 389
	Unprotocol 389
	合同是艰难的 390
	如何编写Unprotocol 391
	为什么使用GPLv3 的公开规范 392
	使用ABNF 393
	廉价或讨厌的模式 393
	序列化数据 395
	φMQ 组帧 396
	序列化语言 396
	序列化库 397
	手写的二进制序列化 399
	代码生成 400
	传输文件 406
	状态机 417
	使用SASL 认证 424
	大型文件发布：FileMQ 426
	为什么要制作FileMQ 426
	最初的设计切片：API 426
	最初的设计切片：协议 427
	构建和尝试FileMQ 429
	内部架构 430
	公共API 431
	设计说明 432
	配置 433
	文件稳定性 434
	递交通知 434
	符号链接 435
	恢复和后期加入者 435
	测试用例：曲目工具 437
	得到一个官方端口号 439

### 第8 章 分布式计算的框架 441

	用于现实世界的设计 442
	无线网络的秘密生活 443
	为什么网状网络现在还没出现 444
	一些物理知识 445
	现状是什么 446
	结论 448
	发现 448
	通过原始套接字先发制人的发现 448
	使用UDP 广播协同发现 450
	一台设备上的多个节点 455
	设计API 456
	关于UDP 的更多内容 465
	分拆一个库项目 466
	点对点消息传递 467
	UDP 信标帧 467
	真正的对等连接（和谐模式） 469
	检测失踪 471
	群发消息 472
	测试与模拟 474
	使用断言 474
	前期测试 475
	Zyre 测试仪 476
	测试结果 479
	跟踪活动 481
	处理阻塞节点 481
	分布式日志记录和监视 484
	一个合理的最小实现 485
	协议断言 488
	二进制日志记录协议 489
	内容分发 490
	编写Unprotocol 493
	结论 494

### 第9 章 后记 497

	番外篇 497
	Rob Gagnon 的故事 497
	Tom van Leeuwen 的故事 497
	Michael Jakl 的故事 498
	Vadim Shalts 的故事 498
	本书是如何诞生的 499
	消除摩擦 500

### 许可 502

### 索引 503 