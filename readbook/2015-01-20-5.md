tags: read
title: 《操作系统——精髓与设计原理（第七版）》- 目录

#### 第0章 读者与教师指南 1

	0.1 本书概述 1
	0.2 实例系统 1
	0.3 读者和教师的学习路线图 2
	0.4 互联网和网站资源 3

## 第一部分 背景知识


#### 第1章 计算机系统概述 6

	1.1 基本构成 6
	1.2 微处理器的发展演化 7
	1.3 指令的执行 8
	1.4 中断 10
	1.4.1 中断和指令周期 11
	1.4.2 中断处理 14
	1.4.3 多个中断 16
	1.5 存储器的层次结构 17
	1.6 高速缓存 19
	1.6.1 动机 19
	1.6.2 高速缓存原理 20
	1.6.3 高速缓存设计 22
	1.7 直接内存存取 22
	1.8 多处理器和多核计算机组织结构 23
	1.8.1 对称多处理器 24
	1.8.2 多核计算机 25
	1.9 推荐读物和网站 26
	1.10 关键术语、复习题和习题 26
	1.10.1 关键术语 26
	1.10.2 复习题 26
	1.10.3 习题 27
	附录1A 两级存储器的性能特征 29

#### 第2章 操作系统概述 34

	2.1 操作系统的目标和功能 34
	2.1.1 作为用户/计算机接口的操作系统 35
	2.1.2 作为资源管理器的操作系统 36
	2.1.3 操作系统的易扩展性 37
	2.2 操作系统的发展 37
	2.2.1 串行处理 38
	2.2.2 简单批处理系统 38
	2.2.3 多道批处理系统 40
	2.2.4 分时系统 42
	2.3 主要的成就 44
	2.3.1 进程 44
	2.3.2 内存管理 47
	2.3.3 信息保护和安全 48
	2.3.4 调度和资源管理 49
	2.4 现代操作系统的特征 50
	2.5 虚拟机 52
	2.5.1 虚拟机和虚拟化 52
	2.5.2 虚拟机架构 53
	2.6 针对多处理器和多核的操作系统设计考虑因素 54
	2.6.1 对称多处理器计算机的操作系统设计考虑因素 54
	2.6.2 多核计算机的操作系统设计考虑因素 55
	2.7 微软Windows系统简介 56
	2.7.1 历史 56
	2.7.2 现代操作系统 57
	2.7.3 体系结构 57
	2.7.4 客户/服务器模型 60
	2.7.5 线程和SMP 61
	2.7.6 Windows对象 61
	2.7.7 Windows 7中的新特性 62
	2.8 传统的UNIX系统 63
	2.8.1 历史 63
	2.8.2 描述 64
	2.9 现代UNIX系统 65
	2.9.1 System V版本4(简称SVR4) 65
	2.9.2 BSD 66
	2.9.3 Solaris 10 66
	2.10 Linux操作系统 66
	2.10.1 历史 66
	2.10.2 模块结构 67
	2.10.3 内核组件 69
	2.11 Linux Vserver虚机器结构 71
	2.12 推荐读物和网站 72
	2.13 关键术语、复习题和习题 73
	2.13.1 关键术语 73
	2.13.2 复习题 74
	2.13.3 习题 74

## 第二部分 进程


#### 第3章 进程描述和控制 78

	3.1 什么是进程 79
	3.1.1 背景 79
	3.1.2 进程和进程控制块 79
	3.2 进程状态 80
	3.2.1 两状态进程模型 82
	3.2.2 进程的创建和终止 83
	3.2.3 五状态模型 84
	3.2.4 被挂起的进程 87
	3.3 进程描述 91
	3.3.1 操作系统的控制结构 91
	3.3.2 进程控制结构 92
	3.4 进程控制 96
	3.4.1 执行模式 96
	3.4.2 进程创建 97
	3.4.3 进程切换 98
	3.5 操作系统的执行 99
	3.5.1 无进程的内核 100
	3.5.2 在用户进程中执行 100
	3.5.3 基于进程的操作系统 101
	3.6 安全问题 101
	3.6.1 系统访问威胁 102
	3.6.2 对抗措施 103
	3.7 UNIX SVR4进程管理 104
	3.7.1 进程状态 104
	3.7.2 进程描述 106
	3.7.3 进程控制 107
	3.8 小结 108
	3.9 推荐读物 108
	3.10 关键术语、复习题和习题 108
	3.10.1 关键术语 108
	3.10.2 复习题 109
	3.10.3 习题 109

#### 第4章 线程 112

	4.1 进程和线程 112
	4.1.1 多线程 112
	4.1.2 线程功能特性 115
	4.2 线程分类 116
	4.2.1 用户级和内核级线程 116
	4.2.2 其他方案 119
	4.3 多核和多线程 120
	4.3.1 多核系统上的软件性能 121
	4.3.2 应用示例：Valve游戏软件 121
	4.4 Windows 7线程和SMP管理 124
	4.4.1 进程对象和线程对象 125
	4.4.2 多线程 126
	4.4.3 线程状态 126
	4.4.4 对OS子系统的支持 127
	4.4.5 对称多处理的支持 128
	4.5 Solaris的线程和SMP管理 128
	4.5.1 多线程体系结构 128
	4.5.2 动机 129
	4.5.3 进程结构 129
	4.5.4 线程的执行 130
	4.5.5 把中断当做线程 131
	4.6 Linux的进程和线程管理 131
	4.6.1 Linux任务 131
	4.6.2 Linux线程 133
	4.7 Mac OS X的GCD技术 134
	4.8 小结 135
	4.9 推荐读物 136
	4.10 关键术语、复习题和习题 136
	4.10.1 关键术语 136
	4.10.2 复习题 136
	4.10.3 习题 136

#### 第5章 并发性：互斥和同步 140

	5.1 并发的原理 141
	5.1.1 一个简单的例子 142
	5.1.2 竞争条件 143
	5.1.3 操作系统关注的问题 143
	5.1.4 进程的交互 144
	5.1.5 互斥的要求 146
	5.2 互斥：硬件的支持 147
	5.2.1 中断禁用 147
	5.2.2 专用机器指令 147
	5.3 信号量 149
	5.3.1 互斥 153
	5.3.2 生产者/消费者问题 154
	5.3.3 信号量的实现 157
	5.4 管程 159
	5.4.1 使用信号的管程 159
	5.4.2 使用通知和广播的管程 162
	5.5 消息传递 163
	5.5.1 同步 164
	5.5.2 寻址 165
	5.5.3 消息格式 166
	5.5.4 排队原则 166
	5.5.5 互斥 166
	5.6 读者/写者问题 167
	5.6.1 读者优先 168
	5.6.2 写者优先 168
	5.7 小结 171
	5.8 推荐读物 171
	5.9 关键术语、复习题和习题 172
	5.9.1 关键术语 172
	5.9.2 复习题 173
	5.9.3 习题 173

#### 第6章 并发：死锁和饥饿 183

	6.1 死锁原理 183
	6.1.1 可重用资源 186
	6.1.2 可消耗资源 187
	6.1.3 资源分配图 188
	6.1.4 死锁的条件 189
	6.2 死锁预防 190
	6.2.1 互斥 190
	6.2.2 占有且等待 190
	6.2.3 不可抢占 190
	6.2.4 循环等待 190
	6.3 死锁避免 191
	6.3.1 进程启动拒绝 191
	6.3.2 资源分配拒绝 192
	6.4 死锁检测 195
	6.4.1 死锁检测算法 195
	6.4.2 恢复 196
	6.5 一种综合的死锁策略 196
	6.6 哲学家就餐问题 197
	6.6.1 基于信号量解决方案 197
	6.6.2 基于管程解决方案 198
	6.7 UNIX的并发机制 199
	6.7.1 管道 200
	6.7.2 消息 200
	6.7.3 共享内存 200
	6.7.4 信号量 200
	6.7.5 信号 201
	6.8 Linux内核并发机制 202
	6.8.1 原子操作 202
	6.8.2 自旋锁 203
	6.8.3 信号量 204
	6.8.4 屏障 205
	6.9 Solaris线程同步原语 206
	6.9.1 互斥锁 207
	6.9.2 信号量 207
	6.9.3 多读者/单写者锁 207
	6.9.4 条件变量 208
	6.10 Windows 7并发机制 208
	6.10.1 等待函数 208
	6.10.2 分派器对象 209
	6.10.3 临界区 209
	6.10.4 轻量级读者-写者锁和条件变量 210
	6.10.5 锁无关同步机制 210
	6.11 小结 210
	6.12 推荐读物 211
	6.13 关键术语、复习题和习题 211
	6.13.1 关键术语 211
	6.13.2 复习题 212
	6.13.3 习题 212

## 第三部分 内存


#### 第7章 内存管理 218

	7.1 内存管理的需求 218
	7.1.1 重定位 219
	7.1.2 保护 219
	7.1.3 共享 219
	7.1.4 逻辑组织 220
	7.1.5 物理组织 220
	7.2 内存分区 220
	7.2.1 固定分区 221
	7.2.2 动态分区 223
	7.2.3 伙伴系统 225
	7.2.4 重定位 227
	7.3 分页 228
	7.4 分段 230
	7.5 安全问题 231
	7.5.1 缓冲区溢出攻击 231
	7.5.2 预防缓冲区溢出 234
	7.6 小结 234
	7.7 推荐读物 234
	7.8 关键术语、复习题和习题 235
	7.8.1 关键术语 235
	7.8.2 复习题 235
	7.8.3 习题 235
	附录7A 加载和链接 237

#### 第8章 虚拟内存 242

	8.1 硬件和控制结构 242
	8.1.1 局部性和虚拟内存 244
	8.1.2 分页 244
	8.1.3 分段 252
	8.1.4 段页式 253
	8.1.5 保护和共享 254
	8.2 操作系统软件 255
	8.2.1 读取策略 256
	8.2.2 放置策略 256
	8.2.3 置换策略 256
	8.2.4 驻留集管理 261
	8.2.5 清除策略 265
	8.2.6 加载控制 266
	8.3 UNIX和Solaris内存管理 267
	8.3.1 分页系统 267
	8.3.2 内核内存分配器 269
	8.4 Linux内存管理 271
	8.4.1 Linux虚拟内存 271
	8.4.2 内核内存分配 272
	8.5 Windows内存管理 272
	8.5.1 Windows虚拟地址映射 272
	8.5.2 Windows分页 273
	8.6 小结 274
	8.7 推荐读物和网站 274
	8.8 关键术语、复习题和习题 275
	8.8.1 关键术语 275
	8.8.2 复习题 275
	8.8.3 习题 275

## 第四部分 调度


#### 第9章 单处理器调度 280

	9.1 处理器调度的类型 280
	9.1.1 长程调度 282
	9.1.2 中程调度 282
	9.1.3 短程调度 283
	9.2 调度算法 283
	9.2.1 短程调度准则 283
	9.2.2 优先级的使用 284
	9.2.3 选择调度策略 285
	9.2.4 性能比较 292
	9.2.5 公平共享调度 296
	9.3 传统的UNIX调度 298
	9.4 小结 299
	9.5 推荐读物 300
	9.6 关键术语、复习题和习题 300
	9.6.1 关键术语 300
	9.6.2 复习题 300
	9.6.3 习题 301

#### 第10章 多处理器和实时调度 304

	10.1 多处理器调度 304
	10.1.1 粒度 304
	10.1.2 设计问题 305
	10.1.3 进程调度 307
	10.1.4 线程调度 308
	10.2 实时调度 312
	10.2.1 背景 312
	10.2.2 实时操作系统的特点 312
	10.2.3 实时调度 315
	10.2.4 限期调度 315
	10.2.5 速率单调调度 318
	10.2.6 优先级反转 320
	10.3 Linux调度 321
	10.3.1 实时调度 321
	10.3.2 非实时调度 322
	10.4 UNIX SVR4调度 324
	10.5 FreeBSD调度器 325
	10.5.1 优先级 325
	10.5.2 对称多处理器(SMP)与多核支持 326
	10.6 Windows调度 328
	10.6.1 进程和线程优先级 328
	10.6.2 多处理器调度 329
	10.7 Linux虚拟机进程调度 329
	10.8 小结 330
	10.9 推荐读物 330
	10.10 关键术语、复习题和习题 331
	10.10.1 关键术语 331
	10.10.2 复习题 331
	10.10.3 习题 331

## 第五部分 输入/输出和文件


#### 第11章 I/O管理和磁盘调度 336

	11.1 I/O设备 336
	11.2 I/O功能的组织 337
	11.2.1 I/O功能的发展 338
	11.2.2 直接存储器访问 338
	11.3 操作系统设计问题 340
	11.3.1 设计目标 340
	11.3.2 I/O功能的逻辑结构 340
	11.4 I/O缓冲 341
	11.4.1 单缓冲 342
	11.4.2 双缓冲 343
	11.4.3 循环缓冲 343
	11.4.4 缓冲的作用 343
	11.5 磁盘调度 344
	11.5.1 磁盘性能参数 344
	11.5.2 磁盘调度策略 346
	11.6 RAID 349
	11.6.1 RAID级别0 350
	11.6.2 RAID级别1 352
	11.6.3 RAID级别2 352
	11.6.4 RAID级别3 353
	11.6.5 RAID级别4 353
	11.6.6 RAID级别5 354
	11.6.7 RAID级别6 354
	11.7 磁盘高速缓存 354
	11.7.1 设计考虑因素 355
	11.7.2 性能考虑因素 356
	11.8 UNIX SVR4操作系统的I/O 357
	11.8.1 缓冲区高速缓存 357
	11.8.2 字符队列 358
	11.8.3 无缓冲I/O 358
	11.8.4 UNIX设备 359
	11.9 Linux操作系统的I/O 359
	11.9.1 磁盘调度 359
	11.9.2 Linux页面缓存 361
	11.10 Windows操作系统的I/O 361
	11.10.1 基本I/O机制 361
	11.10.2 异步I/O和同步I/O 362
	11.10.3 软件RAID 362
	11.10.4 卷影复制 363
	11.10.5 卷加密 363
	11.11 小结 363
	11.12 推荐读物 363
	11.13 关键术语、复习题和习题 364
	11.13.1 关键术语 364
	11.13.2 复习题 365
	11.13.3 习题 365

#### 第12章 文件管理 367

	12.1 概述 367
	12.1.1 文件和文件系统 367
	12.1.2 文件结构 368
	12.1.3 文件管理系统 369
	12.2 文件组织和访问 371
	12.2.1 堆 373
	12.2.2 顺序文件 373
	12.2.3 索引顺序文件 374
	12.2.4 索引文件 374
	12.2.5 直接文件或散列文件 375
	12.3 B树 375
	12.4 文件目录 377
	12.4.1 内容 377
	12.4.2 结构 378
	12.4.3 命名 379
	12.5 文件共享 380
	12.5.1 访问权限 380
	12.5.2 同时访问 381
	12.6 记录组块 381
	12.7 辅助存储管理 383
	12.7.1 文件分配 383
	12.7.2 空闲空间的管理 386
	12.8 文件系统安全 389
	12.9 UNIX文件管理 390
	12.9.1 索引节点 390
	12.9.2 文件分配 392
	12.9.3 目录 392
	12.9.4 卷结构 392
	12.9.5 传统的UNIX文件访问控制 393
	12.9.6 UNIX中的访问控制列表 394
	12.10 Linux虚拟文件系统 395
	12.10.1 超级块对象 396
	12.10.2 索引节点对象 397
	12.10.3 目录项对象 397
	12.10.4 文件对象 397
	12.11 Windows文件系统 397
	12.11.1 NTFS的重要特征 398
	12.11.2 NTFS卷和文件结构 398
	12.11.3 可恢复性 400
	12.12 小结 401
	12.13 推荐读物 401
	12.14 关键术语、复习题和习题 402
	12.14.1 关键术语 402
	12.14.2 复习题 402
	12.14.3 习题 402

## 第六部分 嵌入式系统


#### 第13章 嵌入式操作系统 406

	13.1 嵌入式系统 406
	13.2 嵌入式操作系统的特点 407
	13.2.1 移植现有的商业操作系统 408
	13.2.2 专用嵌入式操作系统 408
	13.3 eCos 409
	13.3.1 可配置性 409
	13.3.2 eCos组件 411
	13.3.3 eCos调度程序 413
	13.3.4 eCos线程同步 415
	13.4 TinyOS 419
	13.4.1 无线传感器网络 419
	13.4.2 TinyOS的目标 420
	13.4.3 TinyOS的组件 421
	13.4.4 TinyOS的调度程序 422
	13.4.5 配置例子 423
	13.4.6 TinyOS的资源接口 424
	13.5 推荐读物和网站 425
	13.6 关键术语、复习题和习题 426
	13.6.1 关键术语 426
	13.6.2 复习题 426
	13.6.3 习题 427

## 第七部分 计算机安全


#### 第14章 计算机安全威胁 430

	14.1 计算机安全概念 430
	14.2 威胁、攻击和资产 431
	14.2.1 威胁和攻击 431
	14.2.2 威胁和资产 432
	14.3 入侵者 434
	14.3.1 入侵者行为模式 435
	14.3.2 入侵技术 436
	14.4 恶意软件概述 437
	14.4.1 后门 437
	14.4.2 逻辑炸弹 438
	14.4.3 特洛伊木马 438
	14.4.4 移动代码 438
	14.4.5 多威胁恶意软件 439
	14.5 病毒、蠕虫与僵尸 439
	14.5.1 病毒 439
	14.5.2 蠕虫 443
	14.5.3 僵尸 445
	14.6 Rootkit 446
	14.6.1 Rootkit安装 446
	14.6.2 系统级调用攻击 447
	14.7 推荐读物和网站 447
	14.8 关键术语、复习题和习题 448
	14.8.1 关键术语 448
	14.8.2 复习题 449
	14.8.3 习题 449

#### 第15章 计算机安全技术 451

	15.1 身份验证 451
	15.1.1 基于密码的身份验证 451
	15.1.2 基于令牌的身份验证 453
	15.1.3 生物特征识别认证 454
	15.2 访问控制 455
	15.2.1 自主访问控制 456
	15.2.2 基于角色的权限控制 458
	15.3 入侵检测 460
	15.3.1 基本原则 460
	15.3.2 基于主机的入侵检测技术 461
	15.3.3 审计记录 461
	15.4 恶意软件防御 462
	15.4.1 反病毒方法 462
	15.4.2 蠕虫对策 465
	15.4.3 自动代理程序对策 466
	15.4.4 Rootkit对策 466
	15.5 处理缓冲区溢出攻击 466
	15.5.1 编译时防御 467
	15.5.2 运行时防御 468
	15.6 Windows 7安全性 469
	15.6.1 访问控制方案 470
	15.6.2 访问令牌 470
	15.6.3 安全描述符 471
	15.7 推荐读物和网站 473
	15.8 关键术语、复习题和习题 474
	15.8.1 关键术语 474
	15.8.2 复习题 475
	15.8.3 习题 475

## 第八部分 分布式系统


#### 第16章 分布式处理、客户/服务器和集群系统 478

	16.1 客户/服务器计算模型 478
	16.1.1 什么是客户/服务器计算模型 478
	16.1.2 客户/服务器模型的应用 479
	16.1.3 中间件 484
	16.2 面向服务的体系结构 485
	16.3 分布式消息传递 487
	16.3.1 可靠性与不可靠性 489
	16.3.2 阻塞与无阻塞 489
	16.4 远程过程调用 489
	16.4.1 参数传递 490
	16.4.2 参数表示 490
	16.4.3 客户/服务器绑定 491
	16.4.4 同步和异步 491
	16.4.5 面向对象机制 491
	16.5 集群 492
	16.5.1 集群的配置 492
	16.5.2 操作系统的设计问题 493
	16.5.3 集群计算机的体系结构 494
	16.5.4 集群与对称多处理器的比较 495
	16.6 Windows集群服务器 495
	16.7 Beowulf和Linux集群 497
	16.7.1 Beowulf的特性 497
	16.7.2 Beowulf软件 498
	16.8 小结 498
	16.9 推荐读物和网站 498
	16.10 关键术语、复习题和习题 500
	16.10.1 关键术语 500
	16.10.2 复习题 500
	16.10.3 习题 500
	附录A 并发主题 502
	附录B 编程和操作系统项目 516
	术语表 520
	参考书目 526 