title: 《深入理解Scala》-目录
tags: 

# 第1章 Scala-一种混合式编程语言 1

	1.1 Scala的设计哲学 1
	1.2 当函数式编程遇见面向对象 3
	1.2.1 重新发现函数式概念 4
	1.2.2 Google Collections中的函数式概念 6
	1.3 静态类型和表达力 8
	1.3.1 换边 8
	1.3.2 类型推断 9
	1.3.3 抛开语法 10
	1.3.4 隐式转换概念早已有之 11
	1.3.5 使用Scala的implicit关键字 12
	1.4 与JVM的无缝集成 13
	1.4.1 Scala调用Java 13
	1.4.2 Java调用Scala 14
	1.4.3 JVM的优越性 15
	1.5 总结 16

# 第2章 核心规则 17

 	2.1 学习使用Scala交互模式（REPL） 17
	2.1.1 实验驱动开发 19
	2.1.2 绕过积极（eaglerly）解析 20
	2.1.3 无法表现的语言特性 21
	2.2 优先采用面向表达式编程 22
	2.2.1 方法和模式匹配 23
	2.2.2 可变性 24
	2.3 优先选择不变性 26
	2.3.1 判等 27
	2.3.2 并发 31
	2.4 用None不用null 34
	2.5 多态场景下的判等 38
	2.5.1 例子：时间线库 38
	2.5.2 多态判等实现 40
	2.6 总结 43

# 第3章 来点样式—编码规范 44 

	3.1 避免照搬其他语言的编码规范 45
	3.2 空悬的操作符和括号表达式 48
	3.3 使用有意义的命名 50
	3.3.1 命名时避免$符号 51
	3.3.2 使用命名和默认参数 53
	3.4 总是标记覆盖（overriden）方法 56
	3.5 对期望的优化进行标注 61
	3.6 总结 66

# 第4章 面向对象编程 68

 	4.1 限制在对象或特质的body里初始化逻辑的代码 68
	4.1.1 延迟构造 69
	4.12 多重继承又来了 70
	4.2 为特质的抽象方法提供空实现 71
	4.3 组合可以包含继承 76
	4.3.1 通过继承组合成员 79
	4.3.2 经典构造器with a twist 80
	4.3.3 总结 82
	4.4 提升抽象接口为独立特质 82
	4.4.1 和接口交互 84
	4.4.2 从历史中吸取教训 85
	4.4.3 结论 86
	4.5 public接口应当提供返回值 86
	4.6 总结 88

# 第5章 利用隐式转换写更有表达力 89 

	5.1 介绍隐式转换系统 90
	5.1.1 题外话：标识符 91
	5.1.2 作用域和绑定 93
	5.1.3 隐式解析 97
	5.1.4 通过类型参数获得隐式作用域 99
	5.1.5 通过嵌套获得隐式作用域 100
	5.2 隐式视图：强化已存在的类 101
	5.3 隐式参数结合默认参数 106
	5.4 限制隐式系统的作用域 112
	5.4.1 为导入创建隐式转换 112
	5.4.2 没有导入税（import tax）的隐式转换 114
	5.5 总结 118

# 第6章 类型系统 119

 	6.1 类型 120
	6.1.1 类型和路径 121
	6.1.2 type关键字 123
	6.1.3 结构化类型 124
	6.2 类型约束 130
	6.3 类型参数和高阶类型（Higher Kinded Types） 133
	6.3.1 类型参数约束 133
	6.3.2 高阶类型 134
	6.4 型变（Variance） 136
	6.5 存在类型 143
	6.6 总结 148

# 第7章 隐式转换和类型系统结合应用 149

	7.1 上下文边界和视图边界 149
	7.2 用隐式转换来捕捉类型 152
	7.2.1 捕获类型用于运行时计算（capturing types for runtime evaluation） 152
	7.2.2 使用Manifest 153
	7.2.3 捕捉类型约束 154
	7.2.4 特定方法（Specialized method）156
	7.3 使用类型类（type class） 158
	7.3.1 作为类型类的FileLike 161
	7.3.2 类型类的好处 164
	7.4 用类型系统实现条件执行 165
	7.4.1 异构类型List 167
	7.4.2 IndexedView 170
	7.5 总结 177

# 第8章 Scala集合库 178

 	8.1 使用正确的集合类型 179
	8.1.1 集合库继承层次 179
	8.1.2 Traversable 180
	8.1.3 Iterable 184
	8.1.4 Seq 185
	8.1.5 LinearSeq 186
	8.1.6 IndexedSeq 188
	8.1.7 Set 189
	8.1.8 Map 189
	8.2 不可变集合 191
	8.2.1 Vector 191
	8.2.2 List 193
	8.2.3 Stream（流） 194
	8.3 可变集合 197
	8.3.1 ArrayBuffer 197
	8.3.2 混入修改事件发布特质 198
	8.3.3 混入串行化特质 198
	8.4 用视图和并行集合来改变计算策略 199
	8.4.1 视图 200
	8.4.2 并行集合 201
	8.5 编写能处理所有集合类型的方法 204
	8.6 总结 209

# 第9章 Actors 210

 	9.1 使用Actor的时机 210
	9.2 使用有类型的、透明的引用 214
	9.3 把故障限制在故障区里 219
	9.3.1 发散搜集故障区 219
	9.3.2 通常的故障处理实践 222
	9.4 利用排期区控制负载 223
	9.5 动态Actor拓扑 226
	9.6 总结 231

# 第10章 Scala和Java集成 232

 	10.1 Scala/Java不匹配 233
	10.1.1 基础类型自动打包的差异 234
	10.1.2 可见性的差异 238
	10.1.3 不可表达的语言特性 239
	10.2 谨慎使用隐式转换 242
	10.2.1对象标识和判等 242
	10.2.2 链式隐式转换 244
	10.3 小心Java序列化 246
	10.4 注解你的注解 250
	10.4.1 注解目标 252
	10.4.2 Scala和静态属性 253
	10.5 总结 254

# 第11章 函数式编程 255

 	11.1 计算机科学领域的范畴论 255
	11.2 函子（Functor），Monad及它们与范畴的关系 259
	11.3 咖喱化和可应用风格（Applicative style） 264
	11.3.1 咖喱化 265
	11.3.2 可应用风格 267
	11.4 用作工作流的单子 270
	11.5 总结 274 