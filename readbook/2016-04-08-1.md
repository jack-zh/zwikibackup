tags: 
title: 《Elixir程序设计》-目录


### 第1 章 接受现实 1

	编程时应该关注数据转换 1
	借助管道来组合转换 2
	函数是数据转换器 3
	安装 Elixir 3
	运行 Elixir 4
	iex-交互式 Elixir 4
	编译和运行 8
	对阅读本书的建议 9
	练习 9
	换一种方式思考 10

## 第一部分 常规编程

### 第2 章 模式匹配 12

	赋值：并非如你所料 12
	更复杂的匹配 13
	轮到你了15
	用_（下画线）忽略匹配值 15
	每次匹配变量仅绑定一次 15
	轮到你了17
	从另一个角度来看等号 17

### 第3 章 不可变性 18

	你已经拥有了（一些）不可变数据 18
	不可变的数据才是已知的 19
	不可变性对性能的影响 20
	复制数据20
	垃圾回收20
	用不可变数据编写程序 21

### 第4 章 Elixir 基础 22

	内置类型 22
	值类型 23
	整数 23
	浮点数 23
	原子 24
	区间 24
	正则表达式 24
	系统类型 25
	PID 和端口 25
	引用 25
	收集类型 26
	元组 26
	列表 27
	散列表 28
	二进制型29
	命名、源文件、约定、运算符和其他 30
	真值 30
	运算符 31
	小结 32

### 第5 章 匿名函数 33

	函数和模式匹配 34
	轮到你了35
	一个函数，多个函数体 35
	编写更长的代码 36
	轮到你了37
	能返回函数的函数 37
	记住原始环境的函数 38
	参数化函数 39
	轮到你了39
	将函数作为参数来传递 40
	& 运算符 40
	轮到你了42
	函数是核心 42

### 第6 章 模块与命名函数 43

	编译模块 43
	函数体是代码块 44
	轮到你了45
	函数调用与模式匹配 45
	轮到你了48
	哨兵子句 48
	哨兵子句的限制 49
	默认参数 50
	轮到你了53
	私有函数 53
	｜] --美妙的管道运算符 54
	模块 55
	模块指令57
	import 指令 57
	alias 指令 58
	require 指令 58
	模块属性 58
	模块名：Elixir、Erlang 和原子类型 59
	调用 Erlang 的库函数 60
	寻找函数库 60
	轮到你了61

### 第7 章 列表与递归 62

	头部和尾部 62
	使用头部和尾部来处理列表 63
	iex 如何显示列表 64
	使用头部和尾部来构造列表 66
	创建映射函数 67
	在递归过程中跟踪值 68
	轮到你了69
	生成求和函数 69
	轮到你了70
	更复杂的列表模式 71
	列表的列表 71
	轮到你了74
	List 模块实战 75
	与列表友好相处 76

### 第8 章 字典：散列表、散列字典、关键字列表、集合与结构体 77

	如何在散列表、散列字典和关键字列表之间做选择 77
	字典 78
	模式匹配和更新散列表 79
	模式匹配不能绑定键 81
	更新散列表 82
	散列表与结构体 82
	访问结构体的另一种方式 84
	嵌套字典结构 85
	嵌套访问器和非结构体 86
	动态（运行时）嵌套访问器 87
	集合 88
	能力越大，诱惑越大 89

### 第9 章 番外篇-类型是什么 90


### 第10 章 处理收集-Enum 与Stream 92

	Enum--处理收集 92
	关于排序的说明 95
	轮到你了96
	Stream--延迟处理的枚举类型 96
	流是可组合的枚举器 97
	无限流 99
	自定义流99
	流在实际中的应用 104
	Collectable 协议 104
	推导式 105
	推导式也可以处理二进制位 106
	作用域与推导式 107
	推导式的返回值 107
	轮到你了108
	感动过往的神 109

### 第11 章 字符串与二进制型 110

	字符串字面量 110
	Heredoc 111
	魔术符 112
	"字符串"这个名称 113
	单引号字符串--字符编码列表 114
	轮到你了116
	二进制型 117
	双引号字符串是二进制型 118
	字符串与Elixir 库 118
	轮到你了124
	二进制型与模式匹配 124
	用二进制型来处理字符串 124
	轮到你了125
	熟悉却又陌生 126

### 第12 章 控制流 127

	if 与 unless 127
	cond 128
	case 131
	抛出异常 133
	包含异常的设计 133
	四两拨千斤 134
	轮到你了134

### 第13 章 组织项目 136

	项目：从 GitHub 获取 issue 136
	我们的代码将如何工作 137
	任务：用mix 来创建我们的新项目 137
	创建项目树 138
	转换：解析命令行 140
	进阶：编写一些基本的测试 142
	轮到你了144
	转换：从 GitHub 获取数据 144
	任务：使用外部库 145
	寻找库 146
	为项目添加库 146
	轮到你了148
	回到转换148
	转换：转换响应内容 151
	不在 hex 里的依赖项 152
	应用程序配置 152
	转换：为数据排序 153
	转换：取前n 条 155
	轮到你了156
	转换：格式化表格 156
	任务：创建命令行可执行程序 159
	任务：添加日志 161
	任务：测试代码注释 163
	任务：创建项目文档 167
	使用转换数据的方法来编写代码 169
	轮到你了170

### 第14 章 运用多进程 172

	简单的进程 173
	在进程间发送消息 174
	处理多条消息 175
	递归、循环与栈 178
	进程开销 178
	轮到你了181
	进程何时结束 182
	关联两个进程 183
	监控进程185
	轮到你了186
	并行map--Erlang 版本的"Hello, World" 186
	轮到你了187
	斐波那契数服务器 188
	任务调度器 189
	轮到你了192
	代理--一个难题 192
	以进程的方式来思考 194

### 第15 章 节点--分布式服务的关键 195

	命名节点 195
	轮到你了197
	节点、cookie 与安全 198
	给你的进程命名 199
	何时给进程命名 202
	轮到你了202
	I/O、PID 与节点 203
	轮到你了204
	节点是分布式的基础 205

### 第16 章 OTP：服务器 206

	一些 OTP 的定义 206
	OTP 服务器 207
	状态和单个服务器 207
	我们的第一个 OTP 服务器 208
	轮到你了210
	单向调用210
	跟踪服务器的执行情况 212
	轮到你了214
	GenServer 回调函数 214
	给进程命名 216
	整理接口 217
	轮到你了218

### 第17 章 OTP：应用程序监视器 220

	应用程序监视器与工作进程 220
	轮到你了223
	管理重启前后的进程状态 223
	应用程序监视器是可靠性的核心 229
	轮到你了229

### 第18 章 OTP：应用程序 230

	这不是传统的应用程序 230
	应用程序规范文件 231
	将Sequence 程序转变为OTP 应用程序 231
	关于应用参数的更多信息 234
	监视是可靠性的基础 234
	轮到你了235
	热代码交换 235
	OTP 很大--难以置信的大 241
	轮到你了241

### 第19 章 任务与代理 242

	任务 242
	任务与监视 243
	代理 244
	更大的例子 246
	使其分布式运行 248
	使用代理与任务，还是GenServer 249

## 第三部分 更高级的Elixir


### 第20 章 宏与代码求值 252

	实现if 语句 252
	宏注入代码 254
	装载次序255
	quote 函数 256
	将内部表示作为代码使用 256
	unquote 函数 258
	展开列表--unquote_splicing 259
	回到我们的myif 宏 260
	轮到你了261
	使用绑定来注入值 261
	宏是卫生的 263
	执行代码片段的其他方法 264
	宏与运算符 265
	深入研究 266
	更进一步 266
	轮到你了267

### 第21 章 连接多个模块：行为与use 268

	行为 268
	定义行为268
	声明行为269
	use 与 __using__ 270
	放到一起--跟踪方法调用 270
	使用use 275
	轮到你了275

### 第22 章 协议--多态函数 277

	定义协议 277
	实现协议 278
	可用的类型 279
	轮到你了280
	协议和结构体 280
	内置协议：Access 281
	内置协议：Enumerable 282
	内置协议：String.Chars 285
	内置协议：Inspect 286
	协议就是多态 288
	轮到你了288

### 第23 章 更酷的玩意儿 290

	自定义魔术符 290
	获取选项292
	轮到你了293
	多应用的 umbrella 项目 294
	创建 umbrella 项目 295
	创建子项目 295
	LineSigil 项目 296
	Evaluator 项目 296
	连接子项目 297
	别急！还有更多炫酷的玩意儿！ 299
	
### 附录A 异常：raise 与try，catch 与throw 300
	
### 附录B 类型规范与类型检查 306 